{"meta":{"title":"黄文镔的博客","subtitle":"完美运用所学的一切","description":"黄文镔的博客，文章主题围绕Android相关编程技术，主要涉及Java和Kotlin语言","author":"黄文镔","url":"https://coder-ice.gitee.io","root":"/"},"pages":[{"title":"黄文镔的博客 | 404","date":"2020-02-21T08:38:12.952Z","updated":"2019-07-05T05:27:37.060Z","comments":true,"path":"404.html","permalink":"https://coder-ice.gitee.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2019-06-01T05:38:36.000Z","updated":"2019-06-01T07:29:26.338Z","comments":false,"path":"categories/index.html","permalink":"https://coder-ice.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-01T05:35:29.000Z","updated":"2019-06-01T07:29:14.449Z","comments":false,"path":"tags/index.html","permalink":"https://coder-ice.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Kotlin征途（九）：对象表达式、对象声明、伴生对象","slug":"Kotlin征途（九）：对象表达式、对象声明、伴生对象","date":"2020-01-01T03:28:35.000Z","updated":"2020-03-19T08:06:34.287Z","comments":true,"path":"2020/01/01/Kotlin征途（九）：对象表达式、对象声明、伴生对象/","link":"","permalink":"https://coder-ice.gitee.io/2020/01/01/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E%E3%80%81%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 对象表达式1.1 对象表达式的基本格式对象表达式的最基本格式如下： 1234567object &#123; var title: String = \"对象表达式的基本格式\" fun changeTitle() &#123; title = \"对象已改变\" &#125;&#125; 对象可以继承于某个基类，或者实现其他接口: 123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;……&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125; 1.2 对象表达式的使用场景看过了对象表达式的基本格式后，是不是觉得很眼熟？没错，我在Kotlin征途（五）：Kotlin类和对象中写的匿名内部类就是使用了对象表达式： 123456789101112131415161718192021222324252627class Test &#123; var v = \"成员属性\" fun setInterFace(test: TestInterFace) &#123; test.test() &#125;&#125;/** * 定义接口 */interface TestInterFace &#123; fun test()&#125;fun main(args: Array&lt;String&gt;) &#123; var test = Test() /** * 采用对象表达式来创建接口对象，即匿名内部类的实例。 */ test.setInterFace(object : TestInterFace &#123; override fun test() &#123; println(\"对象表达式创建匿名内部类的实例\") &#125; &#125;)&#125; 1.3 作用域匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。 12345678910111213141516class C &#123; // 私有函数，所以其返回类型是匿名对象类型 private fun foo() = object &#123; val x: String = \"x\" &#125; // 公有函数，所以其返回类型是 Any fun publicFoo() = object &#123; val x: String = \"x\" &#125; fun bar() &#123; val x1 = foo().x // 没问题 val x2 = publicFoo().x // 错误：未能解析的引用“x” &#125;&#125; 在对象表达中可以方便的访问到作用域中的其他变量: 123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ……&#125; 2. 对象声明(单例模式)2.1 对象声明(单例模式)的格式Kotlin 使用 object 关键字来声明一个对象。我们可以方便的通过对象声明来获得一个单例。 12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // …… &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ……&#125; 在Kotlin中引用该对象，我们直接使用其名称即可： 1DataProviderManager.registerDataProvider(……) 在Java中则需要特殊使用： 1DataProviderManager.INSTANCE.registerDataProvider(……) 当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。 1234var data1 = DataProviderManagervar data2 = DataProviderManagerdata1.name = \"test\"print(\"data1 name = $&#123;data2.name&#125;\") 2.2 与对象表达式的异同与对象表达式相同的是，对象可以有超类型，可以实现接口： 123456789object DefaultListener : MouseAdapter(), MouseInterface &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125; 与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。 123456789101112131415class Student &#123; var name = \"Mike\" object Book&#123; var count = 3 fun showName()&#123; print&#123;\"show name: $name\"&#125; // 错误，不能访问到外部类的方法和变量 &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var student = Student() student.Book.count // 错误，不能通过外部类的实例访问到该对象 Student.Book.count // 正确&#125; 3. 伴生对象3.1 伴生对象的用法类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。 1234567class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125;val instance = MyClass.create() // 访问到对象的内部元素 我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名： 123456class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion // 可以看做单例模式的另一个表现方式 注意：一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。 3.2 主要使用场景首先，从伴生对象的声明和基本使用就可以看出，伴生对象可以用来表示一个单例，不过得把类的构造方法用private修饰一下。 而另一个主要的用法就是持有静态变量。相信聪明的你已经注意到了，Kotlin中没有static关键字，这让静态变量无法在Kotlin中快乐的玩耍了，不过伴生对象帮了我们一个忙。由于伴生对象在一个类中只存在一个，与静态变量的性质类似，这样我们给伴生对象添加的变量和方法就可以当做静态变量和静态方法使用。 123456789class MyClass &#123; companion object &#123; var myVar = \"var\" fun myFun() &#123; &#125; &#125;&#125;val x = MyClass.Companion.myVarMyClass.Companion.myFun() 3.3 注意伴生对象只是对象虽然伴生对象看起来像单例，伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口： 123456789interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125; 4. 对象表达式、对象声明、伴生对象之间的语义差异表达式、对象声明、伴生对象之间有一个重要的语义差别： 对象表达式是在使用他们的地方立即执行的 对象声明是在第一次被访问到时延迟初始化的 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Kotlin征途（八）：委托","slug":"Kotlin征途（八）：委托","date":"2019-12-15T07:55:08.000Z","updated":"2020-02-21T03:09:40.084Z","comments":true,"path":"2019/12/15/Kotlin征途（八）：委托/","link":"","permalink":"https://coder-ice.gitee.io/2019/12/15/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%A7%94%E6%89%98/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 由委托实现1.1 简单用法委托模式已经证明是实现继承的一个很好的替代方式， 而 Kotlin 可以零样板代码地原生支持它。 Derived 类可以通过将其所有公有成员都委托给指定对象来实现一个接口Base： 123456789101112131415161718interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main() &#123; val b = BaseImpl(10) Derived(b).print() // 输出 10&#125; Derived 的超类型列表中的 by b 子句表示 b 将会在 Derived 中内部存储， 并且编译器将生成转发给 b 的所有 Base 的方法。 1.2 覆盖由委托实现的接口成员覆盖符合预期：编译器会使用 override 覆盖的实现而不是委托对象中的。如果将 override fun printMessage() { print(&quot;abc&quot;) } 添加到 Derived，那么当调用 printMessage 时程序会输出abc而不是10： 123456789101112131415161718192021222324252627interface Base &#123; fun printMessage() fun printMessageLine()&#125;class BaseImpl(val x: Int) : Base &#123; override fun printMessage() &#123; print(x) &#125; override fun printMessageLine() &#123; println(x) &#125;&#125;class Derived(b: Base) : Base by b &#123; override fun printMessage() &#123; print(\"abc\") &#125;&#125;fun main() &#123; val b = BaseImpl(10) Derived(b).printMessage() // 输出 abc Derived(b).printMessageLine() // 输出 10&#125; 但请注意，以这种方式重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现： 1234567891011121314151617181920212223242526272829interface Base &#123; val message: String fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override val message = \"BaseImpl: x = $x\" override fun print() &#123; println(message) &#125;&#125;class Derived(b: Base) : Base by b &#123; // 在 b 的 `print` 实现中不会访问到这个属性 override val message = \"Message of Derived\"&#125;fun main() &#123; val b = BaseImpl(10) val derived = Derived(b) derived.print() // 输出 BaseImpl: x = 10 println(derived.message) // 输出 Message of Derived&#125; 2. 委托属性有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们， 但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括： 延迟属性（lazy properties）: 其值只在首次访问时计算； 可观察属性（observable properties）: 监听器会收到有关此属性变更的通知； 把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。 为了涵盖这些（以及其他）情况，Kotlin 支持 委托属性: 12345class Example &#123; var p: String by Delegate()&#125; 语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()与 set()会被委托给它的 getValue() 与setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（与 setValue()——对于var 属性）。 例如: 12345678910111213import kotlin.reflect.KPropertyclass Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return \"$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!\" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(\"$value has been assigned to '$&#123;property.name&#125;' in $thisRef.\") &#125;&#125; 当我们从委托到一个 Delegate 实例的 p 读取时，将调用 Delegate 中的 getValue() 函数， 所以它第一个参数是读出 p 的对象、第二个参数保存了对 p 自身的描述 （例如你可以取它的名字)。 例如: 123val e = Example()println(e.p) 输出结果： 1Example@33a17727, thank you for delegating ‘p’ to me! 类似地，当我们给 p 赋值时，将调用 setValue() 函数。前两个参数相同，第三个参数保存将要被赋予的值： 1e.p = \"NEW\" 输出结果： 1NEW has been assigned to ‘p’ in Example@33a17727. 委托对象的要求规范可以在下文找到。 请注意，自 Kotlin 1.1 起你可以在函数或代码块中声明一个委托属性，因此它不一定是类的成员。 你可以在下文找到其示例。 2.1 标准委托Kotlin 标准库为几种有用的委托提供了工厂方法。 2.1.1 延迟属性 Lazylazy() 是接受一个 lambda 并返回一个 Lazy &lt;T&gt; 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。 123456789val lazyValue: String by lazy &#123; println(\"computed!\") \"Hello\"&#125;fun main() &#123; println(lazyValue) println(lazyValue)&#125; 默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在与属性使用位于相同的线程，那么可以使用 LazyThreadSafetyMode.NONE 模式：它不会有任何线程安全的保证以及相关的开销。 2.1.2 可观察属性 ObservableDelegates.observable() 接受两个参数：初始值与修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值： 12345678910111213141516import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable(\"&lt;no name&gt;\") &#123; prop, old, new -&gt; println(\"$old -&gt; $new\") &#125;&#125;fun main() &#123; val user = User() user.name = \"first\" user.name = \"second\"&#125; 如果你想截获赋值并“否决”它们，那么使用 vetoable() 取代 observable()。 在属性被赋新值生效之前会调用传递给 vetoable 的处理程序。 2.2 把属性储存在映射中一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。 1234567class User(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val age: Int by map&#125; 在这个例子中，构造函数接受一个映射参数： 1234val user = User(mapOf( \"name\" to \"John Doe\", \"age\" to 25)) 委托属性会从这个映射中取值（通过字符串键——属性的名称）： 12println(user.name) // Prints \"John Doe\"println(user.age) // Prints 25 这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话： 1234class MutableUser(val map: MutableMap&lt;String, Any?&gt;) &#123; var name: String by map var age: Int by map&#125; 2.3 局部委托属性（自 1.1 起）你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化： 123456fun example(computeFoo: () -&gt; Foo) &#123; val memoizedFoo by lazy(computeFoo) if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123; memoizedFoo.doSomething() &#125;&#125; memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。 2.4 属性委托要求这里我们总结了委托对象的要求。 对于一个只读属性（即 val 声明的），委托必须提供一个名为 getValue 的函数，该函数接受以下参数： thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型； property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 这个函数必须返回与属性相同的类型（或其子类型）。 对于一个可变属性（即 var 声明的），委托必须额外提供一个名为 setValue的函数，该函数接受以下参数： thisRef —— 同 getValue()； property —— 同 getValue()； new value —— 必须与属性同类型或者是它的子类型。 getValue() 与 setValue() 函数可以通过委托类的成员函数提供或者由扩展函数提供。 当你需要委托属性到原本未提供的这些函数的对象时后者会更便利。 两函数都需要用 operator 关键字来进行标记。 委托类可以实现包含所需operator方法的 ReadOnlyProperty 或 ReadWriteProperty 接口之一。 这俩接口是在 Kotlin 标准库中声明的： 12345678910111213interface ReadOnlyProperty&lt;in R, out T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T&#125;interface ReadWriteProperty&lt;in R, T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)&#125; 2.4.1 翻译规则在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性： 1234567891011121314151617class C &#123; var prop: Type by MyDelegate()&#125;// 这段是由编译器生成的相应代码：class C &#123; private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。 请注意，直接在代码中引用绑定的可调用引用的语法 this::prop 自 Kotlin 1.1 起才可用。 2.4.2 提供委托（自 1.1 起）通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来创建属性委托实例。 provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检测属性一致性。 例如，如果要在绑定之前检测属性名称，可以这样写： 123456789101112131415161718192021222324252627282930class ResourceDelegate&lt;T&gt; : ReadOnlyProperty&lt;MyUI, T&gt; &#123; override fun getValue(thisRef: MyUI, property: KProperty&lt;*&gt;): T &#123; ... &#125;&#125; class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate( thisRef: MyUI, prop: KProperty&lt;*&gt; ): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, prop.name) // 创建委托 return ResourceDelegate() &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;&#125;class MyUI &#123; fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 的参数与 getValue 相同： thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型； property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。 如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便： 12345678910111213141516// 检测属性名称而不使用“provideDelegate”功能class MyUI &#123; val image by bindResource(ResourceID.image_id, \"image\") val text by bindResource(ResourceID.text_id, \"text\")&#125;fun &lt;T&gt; MyUI.bindResource( id: ResourceID&lt;T&gt;, propertyName: String): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(this, propertyName) // 创建委托&#125; 在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与上面（当 provideDelegate 方法不存在时）生成的代码： 1234567891011121314151617class C &#123; var prop: Type by MyDelegate()&#125;// 这段代码是当“provideDelegate”功能可用时由编译器生成的代码：class C &#123; // 调用“provideDelegate”来创建额外的“delegate”属性 private val prop$delegate = MyDelegate().provideDelegate(this, this::prop) var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; 请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Kotlin征途（七）：特殊的类","slug":"Kotlin征途（七）：特殊的类","date":"2019-12-01T12:29:47.000Z","updated":"2020-02-21T03:06:54.216Z","comments":true,"path":"2019/12/01/Kotlin征途（七）：特殊的类/","link":"","permalink":"https://coder-ice.gitee.io/2019/12/01/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 数据类1.1 数据类的定义我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做数据类并标记为data： 1data class User(val name: String, val age: Int) 编译器自动从主构造函数中声明的所有属性导出以下成员： equals()/hashCode() 对； toString() 格式是 User(name=John, age=42)； componentN() 函数 按声明顺序对应于所有属性； copy() 函数（见下文）。 为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求： 主构造函数需要至少有一个参数； 主构造函数的所有参数需要标记为 val 或 var； 数据类不能是抽象、开放、密封或者内部的； （在1.1之前）数据类只能实现接口。 此外，成员生成遵循关于成员继承的这些规则： 如果在数据类体中有显式实现equals()、 hashCode() 或者toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数； 如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错； 从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且在 Kotlin 1.3 中已禁用。 不允许为 componentN() 以及 copy() 函数提供显式实现。 自 1.1 起，数据类可以扩展其他类。 在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 1data class User(val name: String = \"\", val age: Int = 0) 1.2 在类体中声明的属性请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排除一个属性，请将其声明在类体中： 12345data class Person(val name: String) &#123; var age: Int = 0&#125; 在 toString()、equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个Person 对象可以有不同的年龄，但它们会视为相等。 1234val person1 = Person(\"John\")val person2 = Person(\"John\")person1.age = 10person2.age = 20 1.3 复制在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。copy() 函数就是为此而生成。对于上文的User类，其实现会类似下面这样： 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 这让我们可以写： 12val jack = User(name = \"Jack\", age = 1)val olderJack = jack.copy(age = 2) 1.4 数据类与解构声明为数据类生成的Component函数 使它们可在解构声明中使用： 123val jane = User(\"Jane\", 35)val (name, age) = janeprintln(\"$name, $age years of age\") // 输出 \"Jane, 35 years of age\" 2. 密封类密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 要声明一个密封类，需要在类名前面添加sealed修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。 1234567sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() （上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。 ） 一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。 密封类不允许有非private构造函数（其构造函数默认为private）。 请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。 使用密封类的关键好处在于使用when表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个else子句了。当然，这只有当你用when作为表达式（使用结果）而不是作为语句时才有用。 123456fun eval(expr: Expr): Double = when(expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况&#125; 3. 泛型与 Java 类似，Kotlin 中的类也可以有类型参数： 12345class Box&lt;T&gt;(t: T) &#123; var value = t&#125; 一般来说，要创建这样类的实例，我们需要提供类型参数： 1val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1) 但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数： 1val box = Box(1) // 1 具有类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。 3.1 声明处型变我们可以标注 Source 的类型参数 T 来确保它仅从Source&lt;T&gt;成员中返回（生产），并从不被消费。 为此，我们提供out修饰符： 12345678910interface Source&lt;out T&gt; &#123; fun nextT(): T&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs // 这个没问题，因为 T 是一个 out-参数，String是Any的子类型 val outNextT = objects.nextT() // 此时的调用相当于将String类型强转为Any类型，成功运行&#125; 一般原则是：当一个类C的类型参数 T被声明为 out时，它就只能出现在C 的成员的输出位置，但回报是 C&lt;Base&gt; 可以安全地作为 C&lt;Derived&gt;的超类。 简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。 你可以认为 C 是 T 的生产者，而不是 T 的消费者。 out修饰符称为型变注解，并且由于它在类型参数声明处提供，所以我们称之为声明处型变。 另外除了 out，Kotlin 又补充了一个型变注释：in。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable： 1234567891011interface Comparable&lt;in T&gt; &#123; operator fun compareTo(other: T): Int&#125;fun demo(x: Comparable&lt;Number&gt;) &#123; x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型 // 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量 val y: Comparable&lt;Double&gt; = x // OK！&#125; 我们相信 in 和out两词是自解释的（因为它们已经在 C# 中成功使用很长时间了）， 因此上面提到的助记符不是真正需要的。 3.2 使用处型变3.2.1 类型投影将类型参数 T 声明为 out 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回 T！ 一个很好的例子是 Array： 1234567class Array&lt;T&gt;(val size: Int) &#123; fun get(index: Int): T &#123; …… &#125; fun set(index: Int, value: T) &#123; …… &#125;&#125; 该类在 T 上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数： 12345fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) &#123; assert(from.size == to.size) for (i in from.indices) to[i] = from[i]&#125; 这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它： 1234val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)val any = Array&lt;Any&gt;(3) &#123; \"\" &#125;copy(ints, any)// 其类型为 Array&lt;Int&gt; 但此处期望 Array&lt;Any&gt; 这里我们遇到同样熟悉的问题：Array &lt;T&gt; 在T 上是不型变的，因此 Array &lt;Int&gt; 和 Array &lt;Any&gt; 都不是另一个的子类型。为什么？ 再次重复，因为 copy 可能做坏事，也就是说，例如它可能尝试写一个 String到from， 并且如果我们实际上传递一个 Int的数组，一段时间后将会抛出一个 ClassCastException 异常。 那么，我们唯一要确保的是 copy() 不会做任何坏事。我们想阻止它写到 from，我们可以： 1fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) &#123; …… &#125; 这里发生的事情称为类型投影：我们说from不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数 T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array&lt;? extends Object&gt;、 但使用更简单些的方式。 你也可以使用in投影一个类型： 1fun fill(dest: Array&lt;in String&gt;, value: String) &#123; …… &#125; Array&lt;in String&gt; 对应于 Java 的 Array&lt;? super String&gt;，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。 3.2.2 星投影有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型。 Kotlin 为此提供了所谓的星投影语法： 对于 Foo &lt;out T : TUpper&gt;，其中 T 是一个具有上界 TUpper 的协变类型参数，Foo &lt;*&gt; 等价于 Foo &lt;out TUpper&gt;。 这意味着当 T 未知时，你可以安全地从 Foo &lt;*&gt; 读取 TUpper 的值。 对于 Foo &lt;in T&gt;，其中 T 是一个逆变类型参数，Foo &lt;*&gt; 等价于 Foo &lt;in Nothing&gt;。 这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo &lt;*&gt;。 对于 Foo &lt;T : TUpper&gt;，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo&lt;*&gt; 对于读取值时等价于 Foo&lt;out TUpper&gt; 而对于写值时等价于 Foo&lt;in Nothing&gt;。 如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，我们可以想象以下星投影： Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;； Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;； Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;。 注意：星投影非常像 Java 的原始类型，但是安全。 3.3 泛型函数不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前： 1234567fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; // ……&#125;fun &lt;T&gt; T.basicToString(): String &#123; // 扩展函数 // ……&#125; 要调用泛型函数，在调用处函数名之后指定类型参数即可： 1val l = singletonList&lt;Int&gt;(1) 可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用： 1val l = singletonList(1) 4. 枚举类枚举类的最基本的用法是实现类型安全的枚举： 12345enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125; 每个枚举常量都是一个对象。枚举常量用逗号分隔。 4.1 初始化因为每一个枚举都是枚举类的实例，所以他们可以是这样初始化过的： 1234567enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; 4.2 匿名类枚举常量还可以声明其带有相应方法以及覆盖了基类方法的匿名类。 1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125; 如果枚举类定义任何成员，那么使用分号将成员定义中的枚举常量定义分隔开。 枚举条目不能包含内部类以外的嵌套类型（已在Kotlin 1.2中弃用）。 4.3 在枚举类中实现接口一个枚举类可以实现接口（但不能从类继承），可以为所有条目提供统一的接口成员实现，也可以在相应匿名类中为每个条目提供各自的实现。只需将接口添加到枚举类声明中即可，如下所示： 1234567891011enum class IntArithmetics : BinaryOperator&lt;Int&gt;, IntBinaryOperator &#123; PLUS &#123; override fun apply(t: Int, u: Int): Int = t + u &#125;, TIMES &#123; override fun apply(t: Int, u: Int): Int = t * u &#125;; override fun applyAsInt(t: Int, u: Int) = apply(t, u)&#125; 4.4 使用枚举常量Kotlin 中的枚举类也有合成方法允许列出定义的枚举常量以及通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是 EnumClass）： 123EnumClass.valueOf(value: String): EnumClassEnumClass.values(): Array&lt;EnumClass&gt; 如果指定的名称与类中定义的任何枚举常量均不匹配，valueOf() 方法将抛出 IllegalArgumentException 异常。 自 Kotlin 1.1 起，可以使用 enumValues&lt;T&gt;() 与 enumValueOf&lt;T&gt;() 函数以泛型的方式访问枚举类中的常量 ： 123456789enum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE 每个枚举常量都具有在枚举类声明中获取其名称与位置的属性： 12val name: Stringval ordinal: Int 枚举常量还实现了 Comparable 接口， 其中自然顺序是它们在枚举类中定义的顺序。 5. 内联类 内联类仅在 Kotlin 1.3 之后版本可用，目前还是实验性的，本文中简单介绍一下内联类，详细使用等稳定后再总结 有时候，业务逻辑需要围绕某种类型创建包装器。然而，由于额外的堆内存分配问题，它会引入运行时的性能开销。此外，如果被包装的类型是原生类型，性能的损失是很糟糕的，因为原生类型通常在运行时就进行了大量优化，然而他们的包装器却没有得到任何特殊的处理。 为了解决这类问题，Kotlin 引入了一种被称为 内联类 的特殊类，它通过在类的前面定义一个 inline 修饰符来声明： 1inline class Password(val value: String) 内联类必须含有唯一的一个属性在主构造函数中初始化。在运行时，将使用这个唯一属性来表示内联类的实例（关于运行时的内部表达请参阅下文）： 123// 不存在 'Password' 类的真实实例对象// 在运行时，'securePassword' 仅仅包含 'String'val securePassword = Password(\"Don't try this in production\") 这就是内联类的主要特性，它灵感来源于 inline 这个名称：类的数据被 “内联”到该类使用的地方（类似于内联函数中的代码被内联到该函数调用的地方）。","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Kotlin征途（六）：继承、接口、扩展","slug":"Kotlin征途（六）：继承、接口、扩展","date":"2019-11-15T09:32:19.000Z","updated":"2020-02-21T03:06:45.457Z","comments":true,"path":"2019/11/15/Kotlin征途（六）：继承、接口、扩展/","link":"","permalink":"https://coder-ice.gitee.io/2019/11/15/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%89%A9%E5%B1%95/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 继承在 Kotlin 中所有类都有一个共同的超类Any，这对于没有超类型声明的类是默认超类： 1class Example // 从 Any 隐式继承 Any有三个方法：equals()、 hashCode() 与 toString()。因此，为所有 Kotlin 类都定义了这些方法。 如需声明一个显式的超类型，需要使用open关键字修饰超类型，派生类头中把超类型放到冒号之后： 123open class Base(p: Int)class Derived(p: Int) : Base(p) 如果派生类有一个主构造函数，其基类必须用派生类主构造函数的参数就地初始化。如果派生类没有主构造函数，那么每个次构造函数必须使用super关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数： 1234567class MyView : View &#123; constructor(ctx: Context) : super(ctx) constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)&#125; 1.1 覆盖方法Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符： 1234567891011121314open class Shape &#123; open fun draw() &#123; /*……*/ &#125; fun fill() &#123; /*……*/ &#125;&#125;class Circle() : Shape() &#123; // Shape.draw()函数有open修饰，可以覆盖 override fun draw() &#123; /*……*/ &#125;&#125; Circle.draw()函数上必须加上override修饰符。如果没写，编译器将会报错。 如果函数没有标注open如Shape.fill()，那么子类中不允许定义相同签名的函数， 不论加不加override。将open修饰符添加到final类（即没有 open的类）的成员上不起作用。 标记为override的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用final关键字： 123456open class Rectangle() : Shape() &#123; // Rectangle.draw()函数将无法被Rectangle的派生类覆盖 final override fun draw() &#123; /*……*/ &#125;&#125; 1.2 覆盖属性属性覆盖与方法覆盖类似；在超类中声明并用open修饰，然后在派生类中重新声明的属性必须以override开头，并且它们必须具有兼容的类型。 每个声明的属性可以由具有初始化器的属性或者具有get方法的属性覆盖。 1234567891011open class Shape &#123; open val vertexCount: Int = 0&#125;class Rectangle : Shape() &#123; override val vertexCount = 4&#125; 你也可以用一个var属性覆盖一个val属性，但反之则不行。 这是允许的，因为一个val属性本质上声明了一个get方法， 而将其覆盖为var只是在子类中额外声明一个set方法。 请注意，你可以在主构造函数中使用override关键字作为属性声明的一部分。 12345678910111213interface Shape &#123; val vertexCount: Int&#125;class Polygon : Shape &#123; override var vertexCount: Int = 0 // 以后可以设置为任何数&#125;class Rectangle(override val vertexCount: Int = 4) : Shape // 总是有 4 个顶点 1.3 派生类初始化顺序在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。 1234567891011121314151617181920open class Base(val name: String) &#123; init &#123; println(\"Initializing Base\") &#125; open val size: Int = name.length.also &#123; println(\"Initializing size in Base: $it\") &#125;&#125;class Derived(name: String,val lastName: String) : Base(name.capitalize().also &#123; println(\"Argument for Base: $it\") &#125;) &#123; init &#123; println(\"Initializing Derived\") &#125; override val size: Int =(super.size + lastName.length).also &#123; println(\"Initializing size in Derived: $it\") &#125;&#125; 执行代码Constructing Derived(&quot;hello&quot;, &quot;world&quot;)，输出结果为： 12345Argument for Base: HelloInitializing BaseInitializing size in Base: 5Initializing DerivedInitializing size in Derived: 10 这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的open成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及init块中使用open成员。 1.4 调用超类实现派生类中的代码可以使用super关键字调用其超类的函数与属性访问器的实现： 123456789101112131415161718open class Rectangle &#123; open fun draw() &#123; println(\"Drawing a rectangle\") &#125; val borderColor: String get() = \"black\"&#125;class FilledRectangle : Rectangle() &#123; override fun draw() &#123; super.draw() println(\"Filling the rectangle\") &#125; val fillColor: String get() = super.borderColor&#125; 在一个内部类中访问外部类的超类，可以通过由外部类名限定的super关键字来实现：super@Outer： 12345678910111213141516171819class FilledRectangle: Rectangle() &#123; fun draw() &#123; /* …… */ &#125; val borderColor: String get() = \"black\" inner class Filler &#123; fun fill() &#123; /* …… */ &#125; fun drawAndFill() &#123; super@FilledRectangle.draw() // 调用 Rectangle 的 draw() 实现 fill() println(\"Drawn a filled rectangle with color $&#123;super@FilledRectangle.borderColor&#125;\") // 使用 Rectangle 所实现的 borderColor 的 get() &#125; &#125;&#125; 1.5 覆盖规则在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的super，如super&lt;Base&gt;： 123456789101112131415161718192021open class Rectangle &#123; open fun draw() &#123; /* …… */ &#125;&#125;interface Polygon &#123; fun draw() &#123; /* …… */ &#125; // 接口成员默认就是“open”的&#125;class Square() : Rectangle(), Polygon &#123; // 编译器要求覆盖 draw()： override fun draw() &#123; super&lt;Rectangle&gt;.draw() // 调用 Rectangle.draw() super&lt;Polygon&gt;.draw() // 调用 Polygon.draw() &#125;&#125; 可以同时继承Rectangle与Polygon， 但是二者都有各自的draw()实现，所以我们必须在Square中覆盖draw()， 并提供其自身的实现以消除歧义。 1.6 抽象类类以及其中的某些成员可以声明为abstract。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用open标注一个抽象类或者函数——因为这不言而喻。 我们可以用一个抽象成员覆盖一个非抽象的开放成员。 1234567891011open class Polygon &#123; open fun draw() &#123;&#125;&#125;abstract class Rectangle : Polygon() &#123; override abstract fun draw()&#125; 2. 接口Kotlin 的接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。 使用关键字interface来定义接口。 123456789interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 &#125;&#125; 2.1 实现接口一个类或者对象可以实现一个或多个接口。 1234567class Child : MyInterface &#123; override fun bar() &#123; // 方法体 &#125;&#125; 接口的实现方式与继承相似，并且Kotlin的接口可以有属性和实现的方法，可以达到类似于多继承的效果。 2.2 接口中的属性你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。 123456789101112131415161718interface MyInterface &#123; val prop: Int // 抽象的 val propertyWithImplementation: String get() = \"foo\" fun foo() &#123; print(prop) &#125;&#125;class Child : MyInterface &#123; override val prop: Int = 29&#125; 2.3 接口继承一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现： 1234567891011121314151617181920interface Named &#123; val name: String&#125;interface Person : Named &#123; val firstName: String val lastName: String override val name: String get() = \"$firstName $lastName\"&#125;data class Employee( // 不必实现“name” override val firstName: String, override val lastName: String, val position: Position) : Person 2.4 解决覆盖冲突实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如 12345678910111213141516171819202122232425262728293031323334interface A &#123; fun foo() &#123; print(\"A\") &#125; fun bar()&#125;interface B &#123; fun foo() &#123; print(\"B\") &#125; fun bar() &#123; print(\"bar\") &#125;&#125;class C : A &#123; override fun bar() &#123; print(\"bar\") &#125;&#125;class D : A, B &#123; override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125; override fun bar() &#123; super&lt;B&gt;.bar() &#125;&#125; 上例中，接口 A 和 B 都定义了方法foo()和bar()。 两者都实现了foo(), 但是只有 B 实现了bar()(bar() 在 A 中没有标记为抽象， 因为没有方法体时默认为抽象）。因为 C 是一个实现了 A 的具体类，所以必须要重写bar()并实现这个抽象方法。 然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。 3. 扩展Kotlin 能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。 这通过叫做扩展的特殊声明完成。 例如，你可以为一个你不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为扩展函数。此外，也有扩展属性， 允许你为一个已经存在的类添加新的属性。 3.1 扩展函数声明一个扩展函数，我们需要用一个接收者类型也就是被扩展的类型来作为他的前缀。 下面代码为MutableList&lt;Int&gt;添加一个swap函数： 12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 这个this关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，我们对任意MutableList&lt;Int&gt;调用该函数了： 12val list = mutableListOf(1, 2, 3)list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值 当然，这个函数对任何 MutableList 起作用，我们可以泛化它： 12345fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。 3.2 扩展是静态解析的扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。 我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如： 12345678910111213open class Shapeclass Rectangle: Shape() &#123;&#125;fun Shape.getName() = \"Shape\"fun Rectangle.getName() = \"Rectangle\"fun printClassName(s: Shape) &#123; println(s.getName())&#125;printClassName(Rectangle()) 这个例子会输出 “Shape”，因为调用的扩展函数只取决于参数s的声明类型，该类型是Shape类。 如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。 例如： 123456789class Example &#123; fun printFunctionType() &#123; println(\"Class method\") &#125;&#125;fun Example.printFunctionType() &#123; println(\"Extension function\") &#125;Example().printFunctionType() 这段代码输出“Class method”。 当然，扩展函数重载同样名字但不同签名成员函数也完全可以： 123456789class Example &#123; fun printFunctionType() &#123; println(\"Class method\") &#125;&#125;fun Example.printFunctionType(i: Int) &#123; println(\"Extension function\") &#125;Example().printFunctionType(1) 这段代码输出“Extension function”。 3.3 可空接收者注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为null，并且可以在函数体内检测this == null，这能让你在没有检测null的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。 123456fun Any?.toString(): String &#123; if (this == null) return \"null\" // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125; 3.4 扩展属性与函数类似，Kotlin 支持扩展属性： 12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的getters/setters定义。例如: 1val House.number = 1 // 错误：扩展属性不能有初始化器 3.5 伴生对象的扩展如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数与属性。就像伴生对象的常规成员一样， 可以只使用类名作为限定符来调用伴生对象的扩展成员： 123456789class MyClass &#123; companion object &#123; &#125; // 将被称为 \"Companion\"&#125;fun MyClass.Companion.printCompanion() &#123; println(\"companion\") &#125;fun main() &#123; MyClass.printCompanion() &#125; 3.6 扩展的作用域大多数时候我们在顶层定义扩展——直接在包里： 123package org.example.declarationsfun List&lt;String&gt;.getLongestString() &#123; /*……*/&#125; 要使用所定义包之外的一个扩展，我们需要在调用方导入它： 12345678package org.example.usageimport org.example.declarations.getLongestStringfun main() &#123; val list = listOf(\"red\", \"green\", \"blue\") list.getLongestString()&#125; 3.7 扩展声明为成员在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个隐式接收者—— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为分发接收者，扩展方法调用所在的接收者类型的实例称为扩展接收者。 123456789101112131415161718192021222324252627class Host(val hostname: String) &#123; fun printHostname() &#123; print(hostname) &#125;&#125;class Connection(val host: Host, val port: Int) &#123; fun printPort() &#123; print(port) &#125; fun Host.printConnectionString() &#123; printHostname() // 调用 Host.printHostname() print(\":\") printPort() // 调用 Connection.printPort() &#125; fun connect() &#123; /*……*/ host.printConnectionString() // 调用扩展函数 &#125;&#125;fun main() &#123; Connection(Host(\"kotl.in\"), 443).connect() //Host(\"kotl.in\").printConnectionString(443) // 错误，该扩展函数在 Connection 外不可用&#125; 对于分发接收者与扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用限定的this语法。 12345678class Connection &#123; fun Host.getConnectionString() &#123; toString() // 调用 Host.toString() this@Connection.toString() // 调用 Connection.toString() &#125;&#125; 声明为成员的扩展可以声明为open并在子类中覆盖。这意味着这些函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型是静态的。 12345678910111213141516171819202122232425262728293031323334353637open class Base &#123; &#125;class Derived : Base() &#123; &#125;open class BaseCaller &#123; open fun Base.printFunctionInfo() &#123; println(\"Base extension function in BaseCaller\") &#125; open fun Derived.printFunctionInfo() &#123; println(\"Derived extension function in BaseCaller\") &#125; fun call(b: Base) &#123; b.printFunctionInfo() // 调用扩展函数 &#125;&#125;class DerivedCaller: BaseCaller() &#123; override fun Base.printFunctionInfo() &#123; println(\"Base extension function in DerivedCaller\") &#125; override fun Derived.printFunctionInfo() &#123; println(\"Derived extension function in DerivedCaller\") &#125;&#125;fun main() &#123; BaseCaller().call(Base()) DerivedCaller().call(Base()) DerivedCaller().call(Derived())&#125; 输出结果为： 123Base extension function in BaseCallerBase extension function in DerivedCallerBase extension function in DerivedCaller","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Kotlin征途（五）：Kotlin类和对象","slug":"Kotlin征途（五）：Kotlin类和对象","date":"2019-11-01T06:06:20.000Z","updated":"2020-02-21T03:07:14.344Z","comments":true,"path":"2019/11/01/Kotlin征途（五）：Kotlin类和对象/","link":"","permalink":"https://coder-ice.gitee.io/2019/11/01/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AKotlin%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 类定义接触过Java的同学可以很轻松的掌握类的定义。Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。Kotlin 中使用关键字class声明类，后面紧跟类名： 123class SomeThing &#123; // 类名为 SomeThing // 大括号内是类体构成&#125; 我们也可以定义一个空类： 1class Empty 可以在类中定义成员函数： 123class SomeThing() &#123; fun foo() &#123; print(\"Foo\") &#125; // 成员函数&#125; 2. 类的属性2.1 属性定义类的属性可以用关键字var声明为可变的，或关键字val声明为不可变。 1234567class SomeThing &#123; var name: String = \"name\" val type: String = \"type\" name = \"new name\" // 正常使用，重新赋值 type = \"new type\" // 报错，type用val声明，不可变，不可重新赋值&#125; 我们可以像使用普通函数那样使用构造函数创建类实例： 1val thing = SomeThing() // Kotlin 中没有 new 关键字 要使用一个属性，只要用名称引用它即可 12thing.name // 使用 . 号来引用thing.type Koltin 中的类可以有一个主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后: 1class Person constructor(firstName: String) &#123;&#125; 如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。 12class Person(firstName: String) &#123;&#125; 2.2 getter 和 setter属性声明的完整语法： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] getter和setter都是可选。如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。 1234var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1 // 类型为 Int, 默认实现了 getter 和 setterval simple: Int? // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1 // 类型为 Int 类型,默认实现 getter 以下实例定义了一个 Person 类，包含两个可变变量lastName和no，lastName修改了getter方法，no修改了setter方法。 1234567891011121314151617181920212223242526272829303132333435class Person &#123; var lastName: String = \"zhang\" get() = field.toUpperCase() // 变量取值时先转换为大写 set var no: Int = 100 get() = field // 后端变量 set(value) &#123; if (value &lt; 10) &#123; // 如果传入的值小于 10 返回该值 field = value &#125; else &#123; field = -1 // 如果传入的值大于等于 10 返回 -1 &#125; &#125; var heiht: Float = 145.4f private set&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; var person: Person = Person() person.lastName = \"wang\" println(\"lastName:$&#123;person.lastName&#125;\") person.no = 9 println(\"no:$&#123;person.no&#125;\") person.no = 20 println(\"no:$&#123;person.no&#125;\")&#125; 输出结果为： 123lastName:WANGno:9no:-1 Kotlin 中类不能有字段。提供了Backing Fields(后端变量) 机制,备用字段使用field关键字声明，field 关键词只能用于属性的访问器，如以上实例： 123456789var no: Int = 100 get() = field // 后端变量 set(value) &#123; if (value &lt; 10) &#123; // 如果传入的值小于 10 返回该值 field = value &#125; else &#123; field = -1 // 如果传入的值大于等于 10 返回 -1 &#125; &#125; 在getter/setter方法中，要使用该属性的值必须使用field关键字，若直接使用属性名将导致getter/setter方法被调用。 非空属性必须在定义的时候初始化，kotlin提供了一种可以延迟初始化的方案，使用 lateinit 关键字描述属性： 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125; 3. 主构造器主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用init关键字作为前缀。 12345class Person constructor(firstName: String) &#123; init &#123; println(\"FirstName is $firstName\") &#125;&#125; 注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）： 123class People(val firstName: String, val lastName: String) &#123; //...&#125; 如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。 实例。创建一个SomeThing类，并通过构造函数传入名称： 1234567891011121314151617181920class SomeThing constructor(name: String) &#123; // 类名为 SomeThing // 大括号内是类体构成 var type: String = \"BigThing\" var name = name init &#123; println(\"初始化名字: $&#123;name&#125;\") &#125; fun printTest() &#123; println(\"我是类的函数\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val thing = SomeThing(\"好大一个东西\") println(thing.name) println(thing.type) thing.printTest()&#125; 输出结果为： 1234初始化名字: 好大一个东西好大一个东西BigThing我是类的函数 4. 次构造函数类也可以有二级构造函数，需要加前缀constructor: 12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用this关键字： 12345class Person(val name: String) &#123; constructor (name: String, age:Int) : this(name) &#123; // 初始化... &#125;&#125; 如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是public。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数： 12class DontCreateMe private constructor () &#123;&#125; 注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。 1class Customer(val customerName: String = \"\") 5. 抽象类抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。 注意：无需对抽象类或抽象成员标注open注解。 1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 6. 嵌套类我们可以把类嵌套在其他类中，看以下实例： 1234567891011class Outer &#123; // 外部类 private val bar: Int = 1 class Nested &#123; // 嵌套类 fun foo() = 2 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性 println(demo) // == 2&#125; 嵌套类相当于Java中的静态内部类，在其他类中构建Outer的嵌套类使用方式如下： 1var demo = Outter.Nested()// 嵌套类，Outter后边没有括号 7. 内部类内部类使用inner关键字来表示。 内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。 12345678910111213141516171819class Outer &#123; private val bar: Int = 1 var v = \"成员属性\" /**嵌套内部类**/ inner class Inner &#123; fun foo() = bar // 访问外部类成员 fun innerTest() &#123; var o = this@Outer //获取外部类的成员变量 println(\"内部类可以引用外部类的成员，例如：\" + o.v) &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val demo = Outer().Inner().foo() println(demo) // 1 val demo2 = Outer().Inner().innerTest() println(demo2) // 内部类可以引用外部类的成员，例如：成员属性&#125; 为了消除歧义，要访问来自外部作用域的this，我们使用this@label，其中@label是一个 代指this来源的标签。 内部类与Java中的内部类基本一致，在其他类中构建Outer的内部类使用方式如下： 1var demo = Outter().Inner();// 内部类，Outter后边有括号 8. 匿名内部类使用对象表达式来创建匿名内部类，必须使用object关键字： 123456789101112131415161718192021222324252627class Test &#123; var v = \"成员属性\" fun setInterFace(test: TestInterFace) &#123; test.test() &#125;&#125;/** * 定义接口 */interface TestInterFace &#123; fun test()&#125;fun main(args: Array&lt;String&gt;) &#123; var test = Test() /** * 采用对象表达式来创建接口对象，即匿名内部类的实例。 */ test.setInterFace(object : TestInterFace &#123; override fun test() &#123; println(\"对象表达式创建匿名内部类的实例\") &#125; &#125;)&#125; 9. 类的修饰符类的修饰符包括classModifier和accessModifier两大类: 1234567891011121314// classModifier: 类属性修饰符，标示类本身特性。abstract // 抽象类 final // 类不可继承，默认属性enum // 枚举类open // 类可继承，类默认是final的annotation // 注解类// accessModifier: 访问权限修饰符private // 仅在同一个文件中可见protected // 同一个文件中或子类可见public // 所有调用的地方都可见internal // 同一个模块中可见 实例 12345678// 文件名：example.ktpackage fooprivate fun foo() &#123;&#125; // 在 example.kt 内可见public var bar: Int = 5 // 该属性随处可见internal val baz = 6 // 相同模块内可见","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Kotlin征途（四）：Kotlin控制语句","slug":"Kotlin征途（四）：Kotlin控制语句","date":"2019-10-15T03:39:15.000Z","updated":"2020-02-21T03:07:06.771Z","comments":true,"path":"2019/10/15/Kotlin征途（四）：Kotlin控制语句/","link":"","permalink":"https://coder-ice.gitee.io/2019/10/15/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AKotlin%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 条件控制语句1.1 if条件语句一个 if 语句包含一个布尔表达式和一条或多条语句，完全兼容Java的使用方式，一个if关键字可匹配最多一个else关键字和多个else if关键字。 12345678910111213// 传统用法var max = aif (a &lt; b) max = b// 使用 else 和 else ifvar max: Intif (a &gt; b) &#123; max = a&#125; else if (a &lt; b) &#123; max = b&#125; else &#123; max = a&#125; Kotlin还具有一个很方便的特性，if表达式可以将结果(执行语句块中的最后一行需为常量值或变量值)直接赋值给一个变量，这也说明我也不需要像Java那种有一个三元操作符? :，因为我们可以使用if来简单实现。 1234567891011// 一般用法val max = if (a &gt; b) &#123; print(\"Choose a\") a&#125; else &#123; print(\"Choose b\") b&#125;// 用于取代Java中的三元操作符 ? :val max = if (a &gt; b) a else b 1.2 when条件语句when将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。 when既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。 when类似其他语言的switch操作符。其最简单的形式如下： 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; print(\"x 不是 1 ，也不是 2\") &#125;&#125; 在when中，else同switch的default。如果其他分支都不满足条件将会求值else分支。 如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔： 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; when也可以用来取代if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支： 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; 2. 循环控制语句2.1 for循环语句for循环可以对任何提供迭代器iterator的对象进行遍历，条件的指定用的是in运算符来确定循环次数（关于in运算符的其他用法可看本文3.2.1 in运算符），语法为for (item in collection) print(item)，循环体可以是一个代码块: 123for (item: Int in ints) &#123; // ……&#125; 如上所述，for可以循环遍历任何提供了迭代器的对象，使用方式与Java中的foreach语句非常相像。如果你想要通过索引遍历一个数组或者一个list，你可以这么做： 123for (i in array.indices) &#123; print(array[i])&#125; 注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。或者你可以用库函数withIndex： 123for ((index, value) in array.withIndex()) &#123; println(\"the element at $index is $value\")&#125; 而要达成在Java中平常经常使用的形式，需要使用区间来完成： 12345678910111213// 正常循环：for (i in 1..4) print(i) // 打印结果为: \"1234\"// 如果你需要按反序遍历整数可以使用标准库中的 downTo() 函数:for (i in 4 downTo 1) print(i) // 打印结果为: \"4321\"// 也支持指定步长：for (i in 1..4 step 2) print(i) // 打印结果为: \"13\"for (i in 4 downTo 1 step 2) print(i) // 打印结果为: \"42\"// 如果循环中不要最后一个范围区间的值可以使用 until 函数:for (i in 1 until 4) print(i) // 打印结果为: \"123\" 2.2 while与do…while循环语句while是最基本的循环，它的结构为： 123while( 布尔表达式 ) &#123; //循环内容&#125; 对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。 123do &#123; //代码语句&#125;while(布尔表达式); 实例 123456789101112fun main(args: Array&lt;String&gt;) &#123; println(\"----while 使用-----\") var x = 5 while (x &gt; 0) &#123; print( x--) &#125; println(\"----do...while 使用-----\") var y = 5 do &#123; print(y--) &#125; while(y&gt;0)&#125; 输出结果： 1234----while 使用-----54321----do...while 使用-----54321 3. 其他控制语句3.1 返回和跳转Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 在循环中 Kotlin 支持传统的 break 和 continue 操作符。 1234567891011121314fun main(args: Array&lt;String&gt;) &#123; for (i in 1..10) &#123; if (i==3) continue // i 为 3 时跳过当前循环，继续下一次循环 println(i) if (i&gt;5) break // i 为 6 时 跳出循环 &#125;&#125;//输出结果：12456 在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟@符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。现在，我们可以用标签限制break或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 标签限制的break跳转到刚好位于该标签指定的循环后面的执行点。continue继续标签指定的循环的下一次迭代。 Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的return允许我们从外层函数返回。 最重要的一个用途就是从lambda表达式中返回。回想一下我们这么写的时候： 123456fun foo() &#123; ints.forEach &#123; if (it == 0) return print(it) &#125;&#125; 这个return表达式从最直接包围它的函数即foo中返回。 （注意，这种非局部的返回只支持传给内联函数的lambda表达式。） 如果我们需要从lambda表达式中返回，我们必须给它加标签并用以限制return。 123456fun foo() &#123; ints.forEach lit@ &#123; if (it == 0) return@lit print(it) &#125;&#125; 现在，它只会从lambda表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该lambda的函数同名。 123456fun foo() &#123; ints.forEach &#123; if (it == 0) return@forEach print(it) &#125;&#125; 或者，我们用一个匿名函数替代lambda表达式。 匿名函数内部的return语句将从该匿名函数自身返回 123456fun foo() &#123; ints.forEach(fun(value: Int) &#123; if (value == 0) return print(value) &#125;)&#125; 当要返一个回值的时候，解析器优先选用标签限制的return，即 1return@a 1 意为”从标签@a返回 1”，而不是”返回一个标签标注的表达式@a 1“。 3.2 条件指定的几种特殊方式3.2.1 in运算符使用in运算符来检测某个数字是否在指定区间内，区间格式为x..y。 12345678910fun main(args: Array&lt;String&gt;) &#123; val x = 5 val y = 9 if (x in 1..8) &#123; println(\"x 在区间内\") &#125; when (y) &#123; in 1..10 -&gt; print(\"y 在区间内\") &#125;&#125; 输出结果为： 12x 在区间内y 在区间内 in运算符也可以用来检测某个元素是否存在于指定集合或列表中。 12345678910fun main(args: Array&lt;String&gt;) &#123; val items = setOf(\"apple\", \"banana\", \"kiwi\") if (\"banana\" in items) &#123; println(\"香蕉\") &#125; when &#123; \"orange\" in items -&gt; println(\"橘子\") \"apple\" in items -&gt; println(\"苹果\") &#125;&#125; 输出结果为： 12香蕉苹果 3.2.2 is运算符is运算符用来检测一个值是is或者不是!is一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需任何额外的检测。 1234567891011fun main(args: Array&lt;String&gt;) &#123; val x = \"string obj 1\" val y = \"string obj 2\" if (x !is Int) &#123; println(\"x不是整型\") &#125; when (y) &#123; is String -&gt; println(\"y是字符串\") else -&gt; false &#125;&#125; 输出结果为： 12x不是整型y是字符串","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"开发书籍阅读总结（一）：HeadFirst设计模式","slug":"开发书籍阅读总结（一）：HeadFirst设计模式","date":"2019-10-01T10:53:53.000Z","updated":"2020-02-21T03:06:16.521Z","comments":true,"path":"2019/10/01/开发书籍阅读总结（一）：HeadFirst设计模式/","link":"","permalink":"https://coder-ice.gitee.io/2019/10/01/%E5%BC%80%E5%8F%91%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"本文用于记录本人阅读完HeadFirst设计模式一书后对此书的总结，总结系个人理解并简化提炼，方便使用设计模式时速查，如有错漏，请积极指出，本人将虚心接受并及时改正。","text":"本文用于记录本人阅读完HeadFirst设计模式一书后对此书的总结，总结系个人理解并简化提炼，方便使用设计模式时速查，如有错漏，请积极指出，本人将虚心接受并及时改正。 1. 策略模式1.1 使用前提多个同类型的不同对象，具有不同表现的同类行为。 1.2 使用方法 建立父类，将对象中相同的方法整合到父类实现。 不同的同类型行为建立对应的接口。 为不同行为实现相应类型的行为接口。 父类持有行为接口对象，子类初始化具体的行为对象。 1.3 解决的问题具有相同属性，但行为（功能）不同的同类型事物。 1.4 案例类图 策略模式类图 2. 观察者模式2.1 使用前提某个对象的属性会对其他对象产生影响，且该属性会产生变化。 2.2 使用方法 建立被观察者接口（注册与移除观察者，通知观察者变化）与观察者接口（观察到变化时触发行为）。 影响其他对象的对象实现被观察者接口，属性变化时通知观察者。 被影响的对象实现观察者接口，实现观察到变化时触发的行为。 2.3 解决的问题当一个对象属性状态改变时，所有依赖他的对象都会收到通知并触发行为。 2.4 案例类图 观察者模式类图 3. 装饰者模式3.1 使用前提已有类具备基本的属性及功能，但新需求需要在原有类的基础上增加属性及功能，新需求不想影响原有类。 3.2 使用方式 为原有类A提取父类B，提取出关键方法； 新建类C继承父类B，实现提取出的关键方法，增加新属性及功能完成新需求； 新建类D继承父类C，持有一个父类B对象，构造方法需要父类B对象作为参数； 创建类A的实例并用于创建类D的实例，完成新需求，类D是类A的装饰者。 3.3 解决的问题在不修改原有类的代码的情况下，为原有类赋予新的属性及功能，达到不影响原有系统的情况下完成新的需求。 3.4 案例类图 装饰者模式类图 4. 工厂模式4.1 使用前提有多个具有不同属性或构造方法但有相似功能的同类产物，需根据条件创建不同的对象。 4.2 使用方式 为所有不同的产物提取父类； 建立工厂父类，统一工厂的创建目标产物对象的方法； 为各个产物建立工厂类，工厂实现创建目标产物对象的方法，完成目标产物对象的构造； 根据条件使用相应的工厂构造出产物。 4.3 解决的问题需要频繁根据条件创建同类别的不同类的对象时，容易产生大量的重复代码，工厂模式可以将对象的创建过程集中在工厂中，上层只需要使用工厂即可。 4.4 案例类图 工厂模式类图 5. 单例模式5.1 使用前提一个类只能有一个实例，且这个实例是全局的（全世界独一无二）。 5.2 使用方式 经典实现：构造方法私有化，静态变量保存单例，提供获取单例的方法，方法中根据单例变量是否为空决定是否调用构造方法； 改善多线程：在经典实现的基础上对单例变量及构造方法进行双重加锁； 最佳实现：在经典实现的基础上改造，单例变量由一个静态内部类持有并构造，根据java的类加载机制，第一次获取单例时将触发静态内部类调用单例的构造方法。(延迟加载，线程安全，) 5.3 解决的问题全局只存在一个该类的实例，保证数据或处理过程的唯一性，并且可以全局使用该实例而无需另外创建实例。 5.4 最佳实现简单例子123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 6. 命令模式6.1 使用前提事件的处理过程需要隐藏，仅暴露事件的整体调用，类似黑盒。 6.2 使用方式 为事件整体建立控制器类，将各个部分整合出执行命令的方法； 将事件的各个过程建立相应的命令类，并将它们的实例传递入控制器的执行方法中； 控制器的执行方法中遍历所有的命令并调用它们的执行方法。 6.3 解决的问题将各个过程封装避免暴露而产生其他问题，让事件的进行顺利无误，但缺乏灵活与可扩展性。 6.4 案例类图 命令模式类图 7. 适配器模式7.1 使用前提能够直接得到的对象不是所需或所能够处理的对象，需要将该对象包装后再应用。 7.2 使用方式 为得到的对象A建立一个适配器类B，类B拥有满足所需的属性和方法； 类B的构造方法中接受一个对象A，并将对象A的属性与方法取出，完成所需的属性赋值与方法处理； 使用时，用得到的对象A来构建一个适配器B，并用适配器B来满足所需。 7.3 解决的问题让本不能满足需求或不能被处理的对象变得满足需求或可以被处理。 7.4 案例类图 适配器模式类图 8 外观模式8.1 使用前提一个系统可完成多个功能，每个功能由多个子系统配合完成，将每个功能单独封装可以让系统更便于使用。 8.2 使用方式 为系统建立外观类，为系统的各个功能构建方法； 外观类的功能方法中整合子系统完成系统的该功能； 使用时仅暴露外观类，子系统隐藏，方便用户直接使用系统功能。 8.3 解决的问题为系统提供一个上层接口，方便用户调用，让系统底层子接口易于使用。 8.4 案例类图 外观模式类图 9 模板方法模式9.1 使用前提多个事件具有多个相似的过程，并且这些事件发生的场景类似。 9.2 使用方式 为这些事件提取父类，这些事件相同的过程由父类统一实现； 事件的过程相似但区别细微，这些过程可由父类构建抽象方法，由子类自行实现； 事件有需要根据条件执行或执行某方法后需要执行额外方法时，可用Hook实现。 9.3 解决的问题让相似的事件抽离成算法框架，具体子步骤可由子类实现不同的具体行为。 9.4 案例类图 模板方法模式类图 10 迭代器模式10.1 使用前提需要遍历集合中的对象，但不想暴露对象的存储方式。 10.2 使用方式 建立迭代器类，持有目标对象的集合（列表/图等等）； 迭代器类实现安卓系统提供的Iterator接口，并实现相应方法。 此模式有系统接口帮助使用，方便快捷。 10.3 解决的问题提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 10.4 案例类图 迭代器模式类图 11 组合模式11.1 使用前提集合的元素也可能是一个集合，需要对集合的各个元素进行处理。 11.2 使用方式 为集合类与元素类提取组件接口，包含集合类和元素类共同的性质与功能； 让集合类与元素类均实现组件接口，集合类将属于元素类的性质与功能委托给自己的元素去完成，元素类处理集合类的性质与功能时将自身当成大小为1的集合。 11.3 解决的问题让集合与元素可以用同样的方式被使用到业务中去。 组合模式与迭代器模式共同使用可以达到1+1&gt;2的效果 11.4 案例类图 组合模式类图 12 状态模式12.1 使用前提一个系统的行为由多个不同但相互联系并能在一定情况下转变的状态所控制。 12.2 使用方式 将系统中会受到影响的行为方法提取到一个状态接口中； 根据系统状态的不同建立不同的状态类，状态类实现状态接口，并根据需要实现相应的行为方法； 当系统状态变化时，将委托对应的状态类完成相应的行为。 12.3 解决的问题让对象在内部状态改变时，轻易的改变自己的行为。 12.4 案例类图 状态模式类图 13 代理模式13.1 使用前提目标对象不可以直接访问，但需要使用该对象的信息或功能。 13.2 使用方式 在目标对象的有效区域内，建立目标对象的代理类，代理类持有目标对象或拥有访问目标对象的能力，并将目标对象的属性及功能包装后暴露出去； 在使用方也可建立使用代理类，用于对接目标代理类，也可直接访问目标代理类，最终完成对目标对象的间接访问。 13.3 解决的问题让代理访问目标对象，可保证访问的成功与安全，用于需要远程访问/直接访问开销巨大/需要安全保障的对象。 13.4 案例类图 代理模式类图 14 设计模式总结14.1 复合模式模式与模式可以携手合作，多个模式的复合模式就成了架构，让合适的模式出现在合适的位置就是优秀的架构。 书中提及了MVC，将设计模式称为MVC的钥匙，解读了MVC中对于设计模式的复合使用。在这字里行间，MVP和MVVM都可以拆解出一个个的设计模式，设计模式就是框架的基础，框架就是模式与模式的复合。 14.2 与设计模式相处 用模式思考； 保持简单； 模式不是万能的； 明确何时该使用模式； 利用模式进行重构； 删除不需要的； 现在不需要就别用。 总结 知道能不能用； 知道该不该用； 把握用不用的度。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://coder-ice.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","permalink":"https://coder-ice.gitee.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://coder-ice.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Kotlin征途（三）：Kotlin基本类型","slug":"Kotlin征途（三）：Kotlin基本类型","date":"2019-09-15T07:41:08.000Z","updated":"2020-02-21T03:07:00.930Z","comments":true,"path":"2019/09/15/Kotlin征途（三）：Kotlin基本类型/","link":"","permalink":"https://coder-ice.gitee.io/2019/09/15/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AKotlin%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. Kotlin基本类型1.1 数字1.1.1 整型整型，即整数，与Java类似，有四种内置的整型类，表示的数值范围有所不同： 类型 位数 可表示的最小值 可表示的最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-231) 2,147,483,647 (231-1) Long 64 -9,223,372,036,854,775,808 (-263) 9,223,372,036,854,775,807 (263-1) 所有以未超出Int最大值的整型值初始化的变量都会推断为Int类型。如果初始值超过了其最大值，那么推断为Long类型。 如需显式指定Long型值，请在该值后追加l或L后缀。 1234val one = 1 // Intval threeBillion = 3000000000 // Longval oneLong = 1L // Longval oneByte: Byte = 1 1.1.2 浮点型Kotlin提供了Float与Double类型。 根据IEEE 754标准， 两种浮点类型的十进制位数（即可以存储多少位十进制数）不同： 类型 位数 可表示的最小值 可表示的最大值 Float 32 1.4E-45 (2-149) 3.4028235E+38 (2128-1) Double 64 4.9E-324 (2-1074) 1.7976931348623157E+308 (21024-1) 与Java所不同的是，Kotlin中的数字没有隐式拓宽转换。 例如，具有Double参数的函数只能对Double值调用，而不能对Float、 Int或者其他数字值调用。 1234567891011fun main() &#123; fun printDouble(d: Double) &#123; print(d) &#125; val i = 1 val d = 1.1 val f = 1.1f printDouble(d) printDouble(i) // 错误：类型不匹配 printDouble(f) // 错误：类型不匹配&#125; 1.1.3 字面常量字面常量这个词很有意思，字面，代表浅显不深入。在Java中，字面常量指的就是普通的数字、字符、字符串，不是这里说的基本类型。比如下面一段Java代码： 1234int a = 1024double b = 20.48char c = 'A'String d = \"Hello World!\" 上述代码中，=右边的就是字面常量，而=左边的是变量。同理，Kotlin中也是这样的情况，下面是所有的字面常量： 十进制：123 长整型以大写的 L 结尾：123L 16 进制以 0x 开头：0x0F 2 进制以 0b 开头：0b00001011 注意：8进制不支持 在Kotlin里有一个很方便的设定，你可以使用下划线使数字常量更易读，而这些下划线并不会编入你的软件中，如： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 1.2 布尔Kotlin中的布尔值与Java中一致，我就不多赘述了。 布尔用 Boolean 类型表示，它有两个值：true 和 false。若需要可空引用布尔会被装箱。内置的布尔运算有： 123456val boolA = trueval boolB = falseboolA || boolB // 短路逻辑或，结果为trueboolA &amp;&amp; boolB // 短路逻辑与，结果为false!boolA // 逻辑非，结果为false 1.3 字符字符在日常开发中不是特别常用，但是它是字符串的组成部分，字符串在日常开发中确实有很重要的地位。 Char（字符型） 必需是单引号 ‘ 包含起来的，比如普通字符 ‘0’，’a’。与 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，如下代码在Kotlin中是不可行的： 12345fun check(c: Char) &#123; if (c == 1) &#123; // 错误：类型不兼容 // ... &#125;&#125; 和Java一样，特殊字符可以用反斜杠转义。 支持这几个转义序列：\\t、 \\b、\\n、\\r、\\&#39;、\\&quot;、\\\\ 和 \\$。 编码其他字符要用 Unicode 转义序列语法：\\uFF00。 1.4 字符串1.4.1 String类型和 Java 一样，String 是不可变的。Kotlin提供了方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历： 1234567val str = \"String\"pritln(str[3]) // 打印出 rfor (c in str) &#123; println(c) // 逐行打印出 S t r i n g&#125; Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如： 1234567fun main(args: Array&lt;String&gt;) &#123; val text = \"\"\" 多行字符串 多行字符串 \"\"\" println(text) // 输出时保留编码时的格式，此次输出的两行字符串之前有一些前置空格&#125; 可以通过 trimMargin() 方法来删除多余的空白。默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。 123456789fun main(args: Array&lt;String&gt;) &#123; val text = \"\"\" |多行字符串 |菜鸟教程 |多行字符串 |Runoob \"\"\".trimMargin() println(text) // 前置空格删除了&#125; 1.4.2 字符串模板Kotlin中，字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符$开头，由一个简单的名字构成： 12345fun main(args: Array&lt;String&gt;) &#123; val i = 10 val s = \"i = $i\" // 相当于Java中的String.format(\"i = %d\", i) println(s) // 输出结果为 \"i = 10\"&#125; 除了插入变量还可插入一行表达式，用花括号扩起来: 12345fun main(args: Array&lt;String&gt;) &#123; val s = \"runoob\" val str = \"$s.length is $&#123;s.length&#125;\" println(str) // 输出结果为 \"runoob.length is 6\"&#125; 原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： 1234fun main(args: Array&lt;String&gt;) &#123; val price = \"$&#123;'$'&#125;9.99\" println(price) // 输出结果为 $9.99&#125; 1.5 数组和Java中的类型后加上[]即可声明数组变量不同，Kotlin的数组用类Array实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值，使用时与Java可以达到一致。 数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组： 12345678910fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 如上所述，[] 运算符代表调用成员函数 get() 和 set()。 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。 除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样。 2. 基本数据类型间的关系2.1 类型比较实际上 Kotlin 中没有基础数据类型，只有封装的类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。基本类型也一样，所以在比较两个类型的时候，就有比较数据大小和比较两个对象是否相同的区别了。 在Java中大家都知道有两种比较类型相等的方式：==双等号与equals()方法。equals()方法可以为我们比较两个变量的数值或者说大小是否相等，==双等号则用于比较两个变量的地址是否相同，基本数据类型这两种方式得到的结果一致。 与Java不同的是，在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。 123456789101112fun main(args: Array&lt;String&gt;) &#123; val a: Int = 10000 println(a === a) // true，值相等，对象地址相等 //经过了装箱，创建了两个不同的对象 val boxedA: Int? = a val anotherBoxedA: Int? = a //虽然经过了装箱，但是值是相等的，都是10000 println(boxedA === anotherBoxedA) // false，值相等，对象地址不一样 println(boxedA == anotherBoxedA) // true，值相等&#125; 2.2 类型转换在Java中，类型装换相当方便，隐式转换和显式转换用起来不亦乐乎。而在Kotlin中，由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误 我们可以代用其toInt()方法。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b.toInt() // OK Kotlin为每种数据类型都提供了下面的这些方法，可以转化为其它的类型： 1234567toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的： 1val l = 1L + 3 // Long + Int =&gt; Long 另外Kotlin也提供了as关键字来完成类型的显式转换，使用方式与二元运算符相同： 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b as Int // OK","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"UDP局域网通信的Java实现及Android平台尝试","slug":"UDP局域网通信的Java实现及Android平台尝试","date":"2019-09-01T07:17:19.000Z","updated":"2020-02-21T03:07:29.808Z","comments":true,"path":"2019/09/01/UDP局域网通信的Java实现及Android平台尝试/","link":"","permalink":"https://coder-ice.gitee.io/2019/09/01/UDP%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1%E7%9A%84Java%E5%AE%9E%E7%8E%B0%E5%8F%8AAndroid%E5%B9%B3%E5%8F%B0%E5%B0%9D%E8%AF%95/","excerpt":"局域网通信已经很少被他人所提及了，我曾经还尝试过通过蓝牙构建通信网络，这次有机会尝试UDP局域网通信，在这里把一些基本过程和在Android平台上的问题记录一下。","text":"局域网通信已经很少被他人所提及了，我曾经还尝试过通过蓝牙构建通信网络，这次有机会尝试UDP局域网通信，在这里把一些基本过程和在Android平台上的问题记录一下。 1. UDP基础知识1.1 什么是UDP Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。RFC 768 描述了 UDP。Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的的事情。面向连接的是 TCP，该协议几乎做了所有的事情。——《百度百科》 根据百度百科的解释，UDP是一个数据传输协议，面向无连接的数据传输方式，说明此协议丢包概率较高，不适合复杂的网络环境。UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序。在局域网中，数据的到达率几乎是可以保证的，因此UDP在局域网通信中拥有比TCP更重要的地位。 1.2 UDP通信基本流程 设定好统一的端口号； 初始化绑定指定端口号的数据接收器； 指定接收方的IP地址； 准备好轻量数据； 发送数据至指定的IP地址； 数据接收器触发后续逻辑。 2. UDP局域网通信的Java实现2.1 UDP广播UDP广播的实现较为简单，其接收方的IP地址固定为255.255.255.255，端口号任选，保证发送方与接收方端口号一致且不与其他程序冲突即可，代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UDPManager &#123; public static final int BUFFER_SIZE = 2048; public DatagramSocket socket; public void init() &#123; try &#123; //先创建一个绑定了端口号为9527的DatagramSocket socket = new DatagramSocket(9527); //开启数据接收器 openReceiver(); //发送广播消息 sendBroadcast(\"Hello World!\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void openReceiver() &#123; //在子线程中循环接收数据 new Thread(new Runnable() &#123; @override public void run() &#123; byte[] buffer = new byte[BUFFER_SIZE]; DatagramPacket dp = new DatagramPacket(buffer, BUFFER_SIZE); while(socket != null) &#123; try &#123; socket.receive(dp); System.out.println(new String(buffer)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start; &#125; public void sendBroadcast(String dataStr) throws IOException &#123; //发送广播消息，消息内容为dataStr if (socket != null) &#123; byte[] buffer = dataStr.getBytes(); DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(\"255.255.255.255\"), 9527); socket.send(packet); &#125; &#125;&#125; 2.2 UDP单播UDP单播的实现与广播类似，其接收方的IP地址需发送消息时传入，端口号任选，保证发送方与接收方端口号一致且不与其他程序冲突即可，在2.1中展示的UDPManager类中增加单播发送方法即可，代码示例如下： 1234567891011public class UDPManager &#123; //··· public void sendSingle(String dataStr, String targetIP) throws IOException &#123; //发送单播消息，消息内容为dataStr，接收方IP地址为targetIP if (socket != null) &#123; byte[] buffer = dataStr.getBytes(); DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(targetIP), 9527); socket.send(packet); &#125; &#125;&#125; 2.3 UDP多播UDP多播的实现类似群聊，需要先加入一个指定IP的群组，之后消息往该IP发送即可，，端口号任选，单播与多播端口号不可相同，保证发送方与接收方端口号一致且不与其他程序冲突即可，并且需要在2.1中展示的UDPManager类中增加MulticastSocket类型的成员变量、修改init方法和openReceiver方法、增加对应的多播方法，代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class UDPManager &#123; //··· //多播地址自选，在224.0.1.0～238.255.255.255之间即可 public static final String MULICAST_ADDRESS = \"224.255.0.1\" public MulticastSocket multiSocket; public void init() &#123; try &#123; //先创建一个绑定了端口号为9527的DatagramSocket socket = new DatagramSocket(9527); //创建一个绑定端口号为9528的MulticastSocket multiSocket = new MulticastSocket(9528); //开启数据接收器 openReceiver(); //加入多播群组 multiSocket.joinGroup(InetAddress.getByName(MULICAST_ADDRESS)) //发送广播消息 sendBroadcast(\"Hello World!\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void openReceiver() &#123; //··· //新建子线程接收多播数据 new Thread(new Runnable() &#123; @override public void run() &#123; byte[] buffer = new byte[BUFFER_SIZE]; DatagramPacket dp = new DatagramPacket(buffer, BUFFER_SIZE); while(multiSocket != null) &#123; try &#123; multiSocket.receive(dp); System.out.println(new String(buffer)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start; &#125; //··· public void sendMultiple(String dataStr) throws IOException &#123; //发送多播消息，消息内容为dataStr if (multiSocket != null) &#123; byte[] buffer = dataStr.getBytes(); DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(MULICAST_ADDRESS), 9528); multiSocket.send(packet); &#125; &#125;&#125; 2.4 局域网通信基础构想在上述三种UDP通信方式的实现过程中，发现广播方式并不能送达局域网中所有接收者，非同一网段下的接收者将无法收到广播消息，而单播及多播是可以做到跨网段的。 初步设想，仅使用多播方式，局域网通信流程大致如下： 用户程序启动，UDP初始化完成； 加入组播，发送用户上线消息，暴露本机信息（IP地址等）； 接收到用户上线消息的接收方将该用户加入在线用户列表，并再发送一次本机的用户上线消息； 用户触发消息发送，消息中附带本机信息（IP地址等）与指定接收方IP地址或是用户名等（可以是数组，指定多个接收方）； 接收方收到消息，判断此消息指定接收方中是否有本机，若有则处理该消息，否则丢弃； 用户关闭程序，发送用户下线消息； 接收到用户下线消息的接收方将该用户移除在线用户列表。 3. Android平台同一wifi环境下的尝试3.1 UDP通信方式上的问题在Android平台上初步尝试了UDP的各个通信方式，发现多播方式受到了极大的影响，经多方查证并多次尝试多播的使用，最后放弃了在Android平台上使用多播方式，如读者有兴趣可以尝试解决一下。 3.2 安卓wifi局域网通信基础构想参考之前的构想，多播方式无法使用的情况下，广播结合单播的方式成为我的备用方案，大致流程如下： 用户程序启动，UDP初始化完成； 发送广播，传输用户上线消息，暴露本机信息（IP地址等）； 接收到广播的接收方将该用户加入在线用户列表，并向该用户发送一次本机的用户上线消息； 用户触发消息发送，以单播的方式发送给指定接收方的IP地址，消息中附带本机信息（IP地址等）； 接收方收到消息，处理该消息。 用户关闭程序，发送用户下线消息； 接收到用户下线消息的接收方将该用户移除在线用户列表。","categories":[{"name":"工作之余","slug":"工作之余","permalink":"https://coder-ice.gitee.io/categories/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://coder-ice.gitee.io/tags/Java/"},{"name":"UDP","slug":"UDP","permalink":"https://coder-ice.gitee.io/tags/UDP/"}]},{"title":"Kotlin征途（二）：Kotlin基本语法","slug":"Kotlin征途（二）：Kotlin基本语法","date":"2019-08-15T06:20:28.000Z","updated":"2020-02-21T03:06:38.094Z","comments":true,"path":"2019/08/15/Kotlin征途（二）：Kotlin基本语法/","link":"","permalink":"https://coder-ice.gitee.io/2019/08/15/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AKotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。","text":"本文将伴随大家进入Kotlin语言的正式学习生涯中，希望大家不要半途而废哦！笔者将Kotlin用于Android开发中，因此将从Android开发的视角叙述相关内容，同时将与Java语言有所联系。 1. 正式进入开发的准备知识1.1 声明包名及导入包包，含义、关键字、使用方式与Java一致，如在包com.my.demo下，导入包android.os.Bundle，代码如下： 123456//源文件顶部//package关键字声明包名package com.my.demo//import关键字导入所需包import android.os.Bundle 1.2 程序入口每个程序都需要一个入口，一个main函数是必不可少的。当然，在Android开发中不需要main函数，而是由系统调用Application和Activity来触发程序的入口。Kotlin的main函数较为简单，代码如下： 12345//fun关键字声明一个函数/方法fun main() &#123; //函数体/方法体，如打印Hello World!文字 println(\"Hello World!\")&#125; 1.3 行注释及块注释在前面的代码中，我用到了许多注释，用来解释说明我写的代码。日常开发中，注释是很有必要的，代码将被你逐渐遗忘，原本的含义也许不易通过代码去理解，良好的注释不仅方便了自己也帮助了别人。在我们的代码中，注释有两种，行注释与块注释，Kotlin中的注释与Java类似，代码示例如下： 123456789//这是一条行注释println(\"Hello World!\") //行末也可以使用行注释/*这是块注释块注释可以包含多行*//*块注释也可在一行中使用*/println(/*块注释也可以插入代码中使用*/\"Hello World!\") 1.4 代码风格Kotlin的代码风格类似多种语言的结合体，可以看到很多Java、C#、C++等语言的影子，官方有提供代码风格指南： 应用风格指南如需根据本风格指南配置 IntelliJ 格式化程序，请安装 Kotlin 插件 1.2.20 或更高版本，转到 Settings | Editor | Code Style | Kotlin，点击右上角的 Set from… 链接，并从菜单中选择 Predefined style | Kotlin style guide。如需验证代码已按风格指南格式化，请转到探查设置（Inspections）并启用 Kotlin | Style issues | File is not formatted according to project settings 探查项。 验证风格指南中描述的其他问题（如命名约定）的附加探查项默认已启用。 包名采用全小写字母（例：package com.my.demopackage），类名采用首字母大写的驼峰式命名（例：class SplahActivity{}），函数名及变量名采用首字母小写的驼峰式命名（例：fun doSomething(){}），常量名采用大写字母与下划线结合的方式（例：const val MAX_COUNT = 8）。 Kotlin语句末尾无需;标识，因此换行是代表语句结束还是未完待续就需要我们仔细观察了。其他一些不影响代码运行的风格就不一一例举了，可以参考官方文档，希望大家好好写代码，不只是关注于功能、性能，还要注意代码的可读性，写出漂亮的代码！ 1.5 是否需要取代findViewById()方法Kotlin在Android开发中有一个自动绑定View控件的特性，很多人都推崇取代findViewById()方法，但在使用中发现，这个特性的适用性不高。 Kotlin可以直接在代码中通过id来使用View控件，如：在SplashActivity的布局activity_splash_layout.xml中，存在一个id为tv_hello_world的TextView，那么在SplashActivity的onCreate()方法中可以使用语句tv_hello_world.setText(&quot;Hello World!&quot;)，无需提前声明一个TextView变量，再经过findViewById()来绑定控件。 但如果是需要同一个类配合多个布局，且布局中存在相同id的控件时，此特性将无法使用；或是ListView、RecyclerView中存在多个Item类型对应不同布局，且布局中存在相同id控件的情况，此特性也无法使用。 此特性还存在可读性问题，布局中id均使用小写字母与下划线结合的方式命名，在类文件中直接当作变量使用，违背了变量采用驼峰式命名的代码风格，并且找不到该变量的声明，使得代码逻辑不易于理解。 综述，个人意见为尽量还是使用findViewById()方法，毕竟我们的代码不能只想着省事。 2. 基本语法结构2.1 函数函数的声明关键字是fun，结束语句是return some，空返回值类型是Unit，返回值类型为Unit时结束语句是return且返回值声明及结束语句都可以省略。基本结构是fun 方法名(入参1名: 入参1类型, 入参2名: 入参2类型): 返回值类型{ 方法体 }，代码示例如下： 123456789101112131415161718//带有两个 Int 参数、返回 Int 的函数fun sum(a: Int, b: Int): Int &#123; return a + b&#125;//将表达式作为函数体、返回值类型自动推断的函数fun sum(a: Int, b: Int) = a + b//函数返回无意义的值fun printSum(a: Int, b: Int): Unit &#123; println(\"sum of $a and $b is $&#123;a + b&#125;\") return&#125;//Unit 返回类型可以省略fun printSum(a: Int, b: Int) &#123; println(\"sum of $a and $b is $&#123;a + b&#125;\")&#125; 2.2 变量变量的声明关键字有两个，var和val，其中val修饰的变量只能被赋值一次，类似Java中被final修饰的变量。一个变量的声明基本结构是var/val 变量名: 变量类型，声明语句后可直接跟= 值进行初始赋值并且此时能够自动推断变量类型（可省略: 变量类型），代码示例如下： 1234567891011121314151617//定义只读局部变量使用关键字 val 定义，只能为其赋值一次val a: Int = 1 // 立即赋值val b = 2 // 自动推断出 `Int` 类型val c: Int // 如果没有初始值类型不能省略c = 3 // 明确赋值//可重新赋值的变量使用 var 关键字var x = 5 // 自动推断出 `Int` 类型x += 1//顶层变量（成员变量）val PI = 3.14var x = 0fun incrementX() &#123; x += 1&#125; 2.3 字符串模板在Java中，字符串要拼接上变量值或是方法的返回值比较不友好，要么用+连接，要么就得使用String.format()方法。在Kotlin中可以在字符串中使用$变量名或是${表达式}的方式在字符串中插入变量或是表达式，代码示例如下： 1234567var a = 1// 模板中的简单名称val s1 = \"a is $a\"a = 2// 模板中的任意表达式val s2 = \"$&#123;s1.replace(\"is\", \"was\")&#125;, but now is $a\" 2.4 空值与Null检测Kotlin著名的空安全使用起来还是很烧脑的，变量默认是不会为空的，未赋值的变量在编译中是会报错的，当某个变量的值可以为null的时候，必须在声明处的类型后添加?来标识该引用可为空，但在使用时就需要进行判空操作了。具体的空安全可以看官方文档，这里就先简单说一下，以后可能会单独写一篇空安全的分析。代码示例如下： 12345678910111213141516171819202122232425262728293031323334//如果 str 的内容不是数字返回 nullfun parseInt(str: String): Int? &#123; // ……&#125;//使用返回可空值的函数fun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2) // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null if (x != null &amp;&amp; y != null) &#123; // 在空检测后，x 与 y 会自动转换为非空值（non-nullable） println(x * y) &#125; else &#123; println(\"'$arg1' or '$arg2' is not a number\") &#125; &#125;//或者fun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2) if (x == null) &#123; println(\"Wrong number format in arg1: '$arg1'\") return &#125; if (y == null) &#123; println(\"Wrong number format in arg2: '$arg2'\") return &#125; // 在空检测后，x 与 y 会自动转换为非空值 println(x * y)&#125; 2.5 类型检测与自动类型转换Kotlin这一特性用起来相当舒服，is运算符检测一个表达式是否某类型的一个实例，如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换，代码示例如下： 123456789101112131415161718192021222324fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // `obj` 在该条件分支内自动转换成 `String` return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125;//或者fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // `obj` 在这一分支自动转换为 `String` return obj.length&#125;//甚至fun getStringLength(obj: Any): Int? &#123; // `obj` 在 `&amp;&amp;` 右边自动转换成 `String` 类型 if (obj is String &amp;&amp; obj.length &gt; 0) &#123; return obj.length &#125; return null&#125; 2.6 条件表达式if语句在Kotlin中基本与Java一致，唯一的不同点在于最后一行代码若是单独的值，将作为if语句的返回值，这一特点用来取代了Java中的a? b : c三元表达式，示例代码如下： 12345678910fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125;//if 也可以用作表达式fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b 2.7 循环表达式2.7.1 for 循环Kotlin中的for循环有点像Java中的foreach语句，基本结构为for (对象 in 列表/数组/区间) { 循环体 }，代码示例如下： 12345678910val items = listOf(\"apple\", \"banana\", \"kiwifruit\")for (item in items) &#123; println(item)&#125;//或者val items = listOf(\"apple\", \"banana\", \"kiwifruit\")for (index in items.indices) &#123; println(\"item at $index is $&#123;items[index]&#125;\")&#125; 2.7.2 while 循环Kotlin中的while循环与Java一致，基本结构为while (循环条件) { 循环体 }，代码示例如下： 123456val items = listOf(\"apple\", \"banana\", \"kiwifruit\")var index = 0while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++&#125; 2.8 when 表达式when表达式类似Java中的switch语句，但是比switch更高级，能够完全取代多个elseif的情况，基本结构为when (变量) { 条件 -&gt; 操作 }，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435//基本使用，类似switchwhen (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; // 注意这个块 print(\"x is neither 1 nor 2\") &#125;&#125;//我们可以用任意表达式（而不只是常量）作为分支条件when (x) &#123; parseInt(s) -&gt; print(\"s encodes x\") else -&gt; print(\"s does not encode x\")&#125;//我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中when (x) &#123; in 1..10 -&gt; print(\"x is in the range\") in validNumbers -&gt; print(\"x is valid\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125;//另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法与属性而无需任何额外的检测。fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125;//when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; 2.9 区间区间这个概念类似于数学中的区间（适用于整数，假设有整数a和b，a&lt;b），形式有三种： a..b，即从a到b之间的所有整数的升序排列，包括a和b，相当于数学中的[a,b]； b downTo a，即从a到b之间的所有整数的降序排列，包括a和b，可以理解成[b,a]； a until b，即从a到b之间的所有整数的升序排列，包括a但不包括b，相当于数学中的[a,b)。 同时，还可以在末尾加上step 整数来指定步长，例如1..5 step 2代表数列{1, 3, 5}。区间一般用于for循环，代码示例如下： 123456789101112for (i in 1..4) print(i)//输出1234for (i in 4 downTo 1) print(i)//输出4321for (i in 1 until 4) print(i)//输出123for (i in 1..8 step 2) print(i)//输出1357` 2.10 创建实例实例的创建，没有关键字的标识，就像函数的调用。常用操作是声明一个变量，赋值为某个对象实例，调用其构造方法，例如val rectangle = Rectangle(5.0, 2.0)，相对于Java来说，省略了new关键字，就像调用了一个返回值类型为Rectangle的方法。","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"APP启动黑屏白屏原因与解决方式","slug":"APP启动黑屏白屏原因与解决方式","date":"2019-08-01T06:55:52.000Z","updated":"2020-02-21T03:06:01.289Z","comments":true,"path":"2019/08/01/APP启动黑屏白屏原因与解决方式/","link":"","permalink":"https://coder-ice.gitee.io/2019/08/01/APP%E5%90%AF%E5%8A%A8%E9%BB%91%E5%B1%8F%E7%99%BD%E5%B1%8F%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/","excerpt":"我们在桌面启动自己辛苦创建的APP时，总是会看到黑屏或是白屏现象，这让人的体验感觉不是很好，看看大厂的APP为什么不会有这个现象？有问题就要解决，即便不是BUG，用户体验一样很重要。","text":"我们在桌面启动自己辛苦创建的APP时，总是会看到黑屏或是白屏现象，这让人的体验感觉不是很好，看看大厂的APP为什么不会有这个现象？有问题就要解决，即便不是BUG，用户体验一样很重要。 1. APP启动黑/白屏的原因首先，我们需要知道一个APP启动时，屏幕上都会有什么。在我们的APP里，显示在屏幕上的自然是各个View了，而我们的View又都是在Activity的onCreate()方法中调用了setContentView()方法，传入了我们的layout文件，也就是我们理论上应该看到的Activity内容。但是Android系统在启动一个新的Activity时，首先进行的并不是绘制Activity的内容，我们来看看一个Activity的UI结构。 Activity UI结构 我们可以看到，一个Activity中在ContentView的外围还有PhoneWindow、DecorView、TitleView，当Activity进行绘制时会先绘制这三个View，这时ContentView还没加载进来，所以什么东西都看不到，系统会将屏幕填充主题默认的背景色，亮系主题填充白色，暗系主题填充黑色，就出现了Activity启动之前的黑/白屏现象。 2. 解决黑/白屏的方法刚才说了，系统会为屏幕填充主题默认的背景色，那么要解决这个问题就应该从屏幕的背景下手了。一想到背景，第一反应就是去layout里设置ContentView的background，但是系统并不会先加载ContentView，那有什么在系统绘制之前就能调整屏幕背景呢？ 注意，系统会填充主题默认的背景色，所以主题会在绘制之前加载，我们可以修改主题的背景达到目的。一般一个APP第一个启动的Activity都是Splash，作为一个Splash并不需要标题栏，而且普遍是全屏的。那么我们可以将主题进行修改一下，大概有两种方式： 将主题背景变成透明的，这样在ContentView加载出来之前，我们会透过启动的Activity看到桌面，就不会有黑/白屏的现象。再把标题栏去掉，把Activity设置成全屏的，效果挺不错，缺点是如果启动的是一个有复杂耗时操作的Activity，那么会有一种延迟的感觉。 1234567&lt;style name=\"AppTheme\" parent=\"android:Theme.Light.NoActionBar\"&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:WindowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 将主题背景设置成一张图片，把标题栏去掉，把Activity设置成全屏的，这这样在ContentView加载出来之前，我们就能看到一张默认背景图，但是图片的屏幕适配问题就需要考虑了，主题里的背景图片会自动拉伸，可能会导致失真或者比例失调的问题。 123456&lt;style name=\"AppTheme\" parent=\"android:Theme.Light.NoActionBar\"&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/bg_splash&lt;/item&gt; &lt;item name=\"android:WindowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 3. 背景显示优化这里再将上述解决方法进行优化，减少用户使用时不好的体验。（PS：当然你可以不做此优化，如果你想忽悠老板，把锅甩给Android系统、手机的硬件配置、UI的图给的不匹配屏幕等等） 3.1 方法一优化方法一中的问题在于延迟感严重，那么我们需要做的就是尽量加快Splash的启动速度，在Splash中不加入任何逻辑操作，并且Application中任何的数据及开源框架的初始化方法都不应调用，当Splash启动完全后，在Splash的OnResume()方法中可以启动子线程进行各初始化操作，宁可让用户在背景图中等待，不要让用户看着手机桌面认为手机死机了。 3.2 方法二优化方法二中的问题在于图片拉伸可能导致失真或者比例失调，使得界面不够美观。简单的方式就是建立各个drawable文件夹，覆盖所有的屏幕尺寸类型，每个文件夹下塞一张让UI做的合理的背景图。这种方法超级令人无语，UI的工作量较大，而且你也不可能覆盖所有的屏幕尺寸，比如这样： 超长的手机屏幕 那么怎样可以拥有更好的用户体验呢？这时候我们需要的是drawable。 3.2.1 drawable的类型在Android中，我们可以使用xml自定义一个drawable，用的最多的场景就是背景图了，Android系统的一些默认图标也都是用xml实现的，当然那涉及到了一些矢量图的知识。 首先我们先了解一下drawable的类型，常见的几种有：BitmapDrawable、ShapeDrawable、StateListDrawable、LevelListDrawable、LayerDrawable、TransitionDrawable、ScaleDrawable、AnimationDrawable、InsetDrawable、NinePatchDrawable、ClipDrawable、VectorDrawable。 这里我采用了LayerDrawable来解决图片拉伸的问题，其他的drawable以后再写一篇文章专门分析各个drawable。 3.2.2 LayerDrawable解决图片拉伸LayerDrawable为什么能解决图片拉伸问题呢？这要从LayerDrawble的性质说起了： XML标签为layer-list 层次化的Drawable合集 可以包含多个item，每个item表示一个Drawable item中可以通过android:drawable直接引用资源 item中可以通过android:top等指定相对于父节点的位置 多个Drawable的层次化叠加，并且可以指定每个Drawable的位置，是不是和layout很像？一些简单的布局显示可以用LayerDrawble来完成，不过只能塞Drawable进去，文字什么的就不行了。 那么我们来看一下一个可以很好适配屏幕的背景图改如何完成。首先在drawable文件夹下建立一个layer-list类型的drawable文件bg_splash.xml，随后写入如下代码： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/bg\"/&gt; &lt;item android:top=\"175dp\"&gt; &lt;bitmap android:gravity=\"top\" android:src=\"@drawable/logo\"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 我们在layer-list中放入了两个item：第一个是一整个页面的背景，可以是图片，但是笔者建议用纯色的ShapeDrawable，一定程度上减少内存开销并且无需考虑图片失真之类的问题；第二个是一个Bitmap，&lt;bitmap&gt;这个标签是按照图片大小插入一张图片，这样避免了图片在屏幕上的拉伸，通过android:top来指定这个item顶部的偏移距离，同样还可以指定android:bottom、android:left、android:right来定位item的位置，随后对&lt;bitmap&gt;的android:gravity设置为top，让logo可以显示在顶部。这样一个能随着屏幕进行适配并且不会失真的背景就做好了，按照方法二设置为android:windowBackground即可。 3.2.3 style主题优化按照方法二的设定，整个App将使用我们制作的bg_splash作为背景，这时候如果不给每个Activity设置背景或者在使用虚拟键盘时，进入App之后屏幕上也会看到bg_splash出现在没有控件的位置，造成用户的疑惑或者反感。 我们知道Activity也是可以设置主题的，那么我们可以给Application设置一个默认的主题AppTheme，然后给SplashActivity设置我们的全屏带背景的主题SplashTheme，这样在我们的SplashActivity中就可以迅速显示启动背景图，进入App中，在其他Activity中也不会出现启动背景图，最终的styles和AndroidManifest文件如下： 123456789101112styles.xml&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@color/colorDefaultBg&lt;/item&gt;&lt;/style&gt;&lt;style name=\"SplashTheme\" parent=\"AppTheme\"&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/bg_splash&lt;/item&gt;&lt;/style&gt; 123456789101112131415161718192021222324AndroidManifest.xml&lt;application android:name=\".MyApplication\" android:theme=\"@style/AppTheme\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:allowBackup=\"true\"&gt; &lt;activity android:name=\".SplashActivity\" android:theme=\"@style/SplashTheme\" android:screenOrientation=\"portrait\" android:configChanges=\"orientation|screenSize|keyboardHidden\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt;","categories":[{"name":"避坑指南","slug":"避坑指南","permalink":"https://coder-ice.gitee.io/categories/%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"优化","slug":"优化","permalink":"https://coder-ice.gitee.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"25类Android常用开源框架","slug":"25类Android常用开源框架","date":"2019-07-15T03:41:22.000Z","updated":"2020-02-21T03:01:23.609Z","comments":true,"path":"2019/07/15/25类Android常用开源框架/","link":"","permalink":"https://coder-ice.gitee.io/2019/07/15/25%E7%B1%BBAndroid%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/","excerpt":"工欲善其事，必先利其器！开源框架奉上，支持开源，不造轮子，巨人带飞！持续更新，让开发更顺利。","text":"工欲善其事，必先利其器！开源框架奉上，支持开源，不造轮子，巨人带飞！持续更新，让开发更顺利。 1. 图片加载，缓存，处理 框架名称 功能描述 Android Universal Image Loader 一个强大的加载，缓存，展示图片的库，已过时 Picasso 一个强大的图片下载与缓存的库 Fresco 一个用于管理图像和他们使用的内存的库 Glide 一个图片加载和缓存的库，使用的App有：网易新闻 GlidePalette Android Lollipop Palette is now easy to use with Glide PicassoPalette Android Lollipop Palette is now easy to use with Picasso Picasso-transformations 一个为Picasso提供多种图片变换的库 Glide-transformations 一个为Glide提供多种图片变换的库 2. 图片裁剪 框架名称 功能描述 uCrop Image Cropping Library for Android，使用的App有：薄荷，哔哩哔哩 android-crop 图片裁剪，使用的App有：网易新闻，芒果TV cropper 图片裁剪开源框架 Android-Image-Cropper Image Cropping Library for Android, optimized for Camera / Gallery PhotoCropper Android 大图片裁剪终极解决方案 android-cropimage CropImage Activity from Gallery.apk packaged as a reusable Android library PhotoCrop A Library which can be used to crop images in Android similar to Facebook and Telegram，使用的App有：快手 3. 图片选择 框架名称 功能描述 MultiImageSelector 图片选择，使用的App有：薄荷 BGAPhotoPicker-Android Android 图片选择、预览、九宫格图片控件、拖拽排序九宫格图片控件 TakePhoto 轻量级Android照片处理框架 RxGalleryFinal Android图片单选/多选、拍照、裁剪、压缩。视频选择和录制。 boxing 一个多媒体选择器库，B站出品。可以选择一张或者多张图片，提供预览和裁剪功能。同样支持gif图，选择视频和图像压缩功能。 4. 图片转换，压缩，滤镜 框架名称 功能描述 Android-gpuimage 一个开源的基于GPU的图像处理库，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜，使用的App有：快手 photoview 使用的App有：薄荷,网易新闻 circleimageview 圆形图片，使用的App有：薄荷 RoundedImageView 圆形图片，使用的App有：薄荷 SelectableRoundedImageView Android ImageView that supports different radii on each corner android-gif-drawable gif图片，使用的App有：网易新闻，快手 Luban 可能是最接近微信朋友圈的图片压缩算法 Compressor Compressor is a lightweight and powerful android image compression library 5. 高斯模糊，毛玻璃，图片模糊 框架名称 功能描述 android-stackblur Android StackBlur is a library that can perform a blurry effect on a Bitmap based on a gradient or radius, and return the result. The library is based on the code of Mario Klingemann. Blurry Blurry is an easy blur library for Android blurkit-android The missing Android blurring library. Fast blur-behind layout that parallels iOS. BlurView Dynamic iOS-like blur of underlying Views for Android ImageBlurring Android blurring image(bitmap) by java and jni 6. 缓存 框架名称 功能描述 LruCache Android原生API，内存缓存 DiskLruCache Java实现基于LRU的磁盘缓存 ASimpleCache 一个为android制定的轻量级的开源缓存框架 base-diskcache Android 缓存库，融合了DiskLruCache和ASimpleCache 7. 网络请求 框架名称 功能描述 httpclient apache开源的网络请求框架，已过时 AsyncHttpClient 基于httpclient封装，已过时 OkHttp Square出品，一个Http与Http/2的客户端 Retrofit Square出品，类型安全的Http客户端 Volley Google推出的Android异步网络请求框架和图片加载框架，使用的App有：网易新闻 从Android 6.0 开始，Google删除了apache的开源网络请求框架httpclient，所以基于httpclient的AsyncHttpClient也不推荐使用了。Volley适合那些请求频繁但数据量不大的场景，不适用于大数据的请求，比如下载文件。Android 6.0 后，Android开始使用OkHttp，而Retrofit是一个网络代理框架，可以更简单的使用OkHttp。 8. 网络解析 框架名称 功能描述 Gson 一个Java序列化/反序列化库，可以将JSON和java对象互相转换 Jackson Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象 Fastjson Java上一个快速的JSON解析器/生成器 HtmlPaser 一种用来解析单个独立html或嵌套html的方式 Jsoup 一个以最好的DOM，CSS和jQuery解析html的库 9. 数据库 框架名称 功能描述 OrmLite JDBC和Android的轻量级ORM java包 Sugar 用超级简单的方法处理Android数据库 GreenDAO 一种轻快地将对象映射到SQLite数据库的ORM解决方案，使用的App有：薄荷，京东 ActiveAndroid 以活动记录方式为Android SQLite提供持久化 SQLBrite SQLiteOpenHelper 和ContentResolver的轻量级包装 android-database-sqlcipher 数据库加密 storio Beautiful API for SQLiteDatabase and ContentResolver realm-java 移动数据库，高性能数据库：一个SQLite和ORM的替换品 ObjectBox 相信不少人都用过GreenDao和EventBus，这两库都是greenrobot公司出品。ObjectBox也是该公司出品。GreenDao号称是最快的与SQLite的对象关系映射（ORM）。但是自从2011年以来，公司声称发现了许多的缺陷，有很多问题影响了性能。所以开发出另外一套性能最好且易用的NoSQL数据库，优于其他数据库5-15倍的性能。 10. 依赖注入 框架名称 功能描述 ButterKnife 将Android视图和回调方法绑定到字段和方法上 Dagger2 一个Android和java快速依赖注射器 AndroidAnotations 快速安卓开发。易于维护 RoboGuice Android平台的Google Guice 已退役 guice Google开发的依赖注入框架 11. 图表Chart 框架名称 功能描述 WilliamChart 创建图表的Android库 HelloCharts 兼容到API8的Android图表库，使用的App有：薄荷 MPAndroidChart 一个强大的Android图表视图/图形库，使用的App有：春雨医生 12. 后台处理 框架名称 功能描述 Tape 一个轻快的，事务性的，基于文件的FIFO的库 Android Priority Job Queue 一个专门为Android轻松调度任务的工作队列 13. 事件总线 框架名称 功能描述 EventBus 安卓优化的事件总线，简化了活动、片段、线程、服务等的通信，使用的App有：薄荷 Otto 一个基于Guava的增强的事件总线 HermesEventBus 一个基于EventBus的、能在进程间发送和接收event的库，在IPC或者插件开发中非常有用 14. 响应式编程 框架名称 功能描述 RxJava JVM上的响应式扩展 RxJavaJoins 为RxJava提供Joins操作 RxAndroid Android上的响应式扩展，在RxJava基础上添加了Android线程调度 RxBinding 提供用RxJava绑定Android UI的API Agera Android上的响应式编程 RxLifecycle Lifecycle handling APIs for Android apps using RxJava 15. Log框架 框架名称 功能描述 Logger 简单，漂亮，强大的Android日志工具 Hugo 在调试版本上注解的触发方法进行日志记录 Timber 一个小的，可扩展的日志工具 16. 测试框架 框架名称 功能描述 Mockito Java编写的Mocking单元测试框架 Robotium Android UI 测试 Robolectric Android单元测试框架 Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等。 17. 调试框架 框架名称 功能描述 Stetho 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试 18. 性能优化 框架名称 功能描述 LeakCanary 内存泄漏检测工具 BlockCanary 轻松找出Android App界面卡顿元凶 ACRA Android应用程序崩溃报告 Google Guava Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。 google protobuf 由google开发，并且在google内部使用。Protobuf的作用和xml、json是一回事，但他是二进制格式，性能好、效率高。 19. 热修复 框架名称 功能描述 tinker 腾讯开源的一个热修复框架 AndFix alibaba热修复框架 dexposed alibaba热修复框架 20. 二维码 框架名称 功能描述 Zxing 一个二维码开源框架 barcodescanner 使用的App有：薄荷 BGAQRCode-Android 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信 QQ 二维码扫描样式 zxing-android-embedded 使用的App有：春雨医生，芒果TV 21. 多媒体 框架名称 功能描述 ijkplayer Bilibili开源的视频播放器 DanmakuFlameMaster Android开源弹幕引擎·烈焰弹幕使，使用的App有：网易新闻 Vitamio 一款全能多媒体开发框架，全面支持硬件解码与 GPU 渲染 FFmpeg 一个基于C语言的多媒体开源框架 百度智能云播放器 百度智能云推出的 Android 平台视频播放器 ExoPlayer Google开源的视频播放器 22. 汉语转拼音 框架名称 功能描述 pinyin4j A copy of http://sourceforge.net/projects/pinyin4j, then deploy it to maven central repository. TinyPinyin 适用于Java和Android的快速、低内存占用的汉字转拼音库。 PinyinSearchLibrary The library of PinyinSearch,a Java Library which provide data parsing methods, data matching method and so on for T9 search and Qwerty search.PinyinSearch = T9Search + QwertySearch pinyin4android 唯品会使用，2011年出了1.0版本后没更新了 23. 下载 框架名称 功能描述 MultiThreadDownload 使用的App有：薄荷 FileDownloader Android 文件下载引擎，稳定、高效、灵活、简单易用 RxDownload 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能 file-downloader 安卓上轻量级Http/Https文件下载框架，我的目标是让安卓文件下载越简单越好，尽可能以最简洁明了的方式完成复杂需求。 24. 动画 框架名称 功能描述 facebook:rebound A Java library that models spring dynamics and adds real world physics to your app ViewAnimator A fluent Android animation library Material-Animations Android Transition animations explanation with examples AndroidViewAnimations Cute view animation collection. ListViewAnimations An Android library which allows developers to easily add animations to ListView items recyclerview-animators An Android Animation library which easily add itemanimator to RecyclerView items. RecyclerViewItemAnimators An Android library which provides simple Item animations to RecyclerView items AnimationEasingFunctions Android Animation Easing Functions. Let’s make animation more real! BaseAnimation BaseAnimation收集网络Android相关动画集合，自定义控件等，近200多种源码 FragmentAnimations 3D animations for support-v4 Fragment transition. AnimatedEditText Androids EditText that animates the typed text. EditText is extended to create AnimatedEditText and a PinEntryEditText. ViewPagerTransforms Library containing common animations needed for transforming ViewPager scrolling for Android v13+ lottie-android Render After Effects animations natively on Android and iOS 25. Android选择器类库 框架名称 功能描述 material-calendarview material design 风格的日历控件使用的App有：薄荷 MaterialDateTimePicker Pick a date or time on Android in style，使用的App有：薄荷 android-times-square Standalone Android widget for picking a single date from a calendar view. AndroidPicker 安卓选择器类库，包括日期时间选择器、单项选择器、地址选择器、颜色选择器、文件目录选择器、数字选择器、星座选择器等。 Android-PickerView 仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果 WheelPicker Simple and fantastic wheel view in realistic effect for android. Android-FilePicker Photopicker and document picker for android NumberPickerView another NumberPicker with more flexible attributes on Android platform Android-PickerView-Library Simple PickerView for Android","categories":[{"name":"开发资源","slug":"开发资源","permalink":"https://coder-ice.gitee.io/categories/%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"框架","slug":"框架","permalink":"https://coder-ice.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"资源","slug":"资源","permalink":"https://coder-ice.gitee.io/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"Kotlin征途（一）：简单APP的制作","slug":"Kotlin征途（一）：简单APP的制作","date":"2019-07-01T08:11:45.000Z","updated":"2020-02-21T03:01:07.392Z","comments":true,"path":"2019/07/01/Kotlin征途（一）：简单APP的制作/","link":"","permalink":"https://coder-ice.gitee.io/2019/07/01/Kotlin%E5%BE%81%E9%80%94%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AE%80%E5%8D%95APP%E7%9A%84%E5%88%B6%E4%BD%9C/","excerpt":"Kotlin语言在谷歌的大力推动下，将来必然需要应用在工作中，虽然现在依然是Java主导，但在GitHub上已经有很多库采用了Kotlin来编写，也有很多新开发的APP用的是Kotlin，大厂也开始试水了，是时候让Kotlin成为我们成功的基石了。","text":"Kotlin语言在谷歌的大力推动下，将来必然需要应用在工作中，虽然现在依然是Java主导，但在GitHub上已经有很多库采用了Kotlin来编写，也有很多新开发的APP用的是Kotlin，大厂也开始试水了，是时候让Kotlin成为我们成功的基石了。 1. 学习Koltin的必要性在进入开发之前，我想先将学习Kotlin的必要性梳理一下。 目前在网络上对Kotlin的批判很多，常常能看到 《抛弃Java 改用 Kotlin 的六个月后,我后悔了》、《从Java到Kotlin,然后又回到Java!》、《Kotlin 并没有想的那么好》 等等，根据2018年调查显示1/4的Java开发者在迁移后表示后悔，详细调查报告名为The State of Kotlin 2018，该报告阐述了Koltin在2018年的情况。 但我本人认为，不论Kotlin目前的稳定性与健壮性如何，将来在Android开发中必然是有它的一席之地。甲骨文与谷歌的官司必然让谷歌不愿意看到自家的系统被他人握有把柄，openJdk不会是一个长久之计。作为一只不断学习进取的程序猿，学习Kotlin语言也是一条不错的路。 就目前来说，Kotlin还有许多不足，建议熟悉Kotlin语法教程后可以去看看 《Kotlin 的陷阱以及如何避免》 之类的文章。当然，一门语言的发展必然要踩许许多多的坑，Kotlin还很年轻，我们应该给它更多的宽容。而且Kotlin相较于Java还是有很多优点的，用Kotlin取缔Java的优缺点并存。 在我看来，学习并尝试使用Kotlin开发Android项目是很有必要的，但贸然使用Kotlin直接在老旧项目中取缔Java也许会导致比较严重的后果。我建议在老旧的项目中使用Kotlin还是需要多斟酌，而在新的项目中完全可以直接使用Kotlin，多观望Kotlin的更新情况，适时更新项目中使用的Kotlin版本，让你的项目和你一起成长。 2. 用Kotlin制作一个简单的APP目前我只在AS中开发APP，本文中所用也是AS，建议使用Eclipse开发的童鞋尽早加入AS的大军。 2.1 用AS建立一个Kotlin Android项目首先是需要建立一个新的项目，打开AS软件，并选择Start a new Android Studio project，如图所示： 新建项目 随后将APP name、domain、location根据所需配置好，在底部将Include Kotlin Support勾选上，如图所示： 勾选Kotlin支持 右下角点Next后，进入Target Android Device选择界面，这里根据所需配置好直接Next就好，如图所示： Target Android Device选择 接下来选择Add No Activity，不然AS直接就建立了一个可以直接运行的Hello World APP，我们还是体会一下建立Kotlin Activity的过程，如图所示： 选择Add No Activity Finish以后，等待AS建立一个新的项目并初始编译完成，我们就可以开始我们的第一个Kotlin APP的制作啦。 在Kotlin项目中，相对于Java的Android项目主要有两个区别： 项目目录下的build.gradle文件的buildscript 123456789buildscript &#123; ext.kotlin_version &#x3D; &#39;1.3.41&#39; ... dependencies &#123; ... classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; ... &#125;&#125; app目录下的build.gradle文件的plugin和dependencies 123456789...apply plugin: &#39;kotlin-android&#39;apply plugin: &#39;kotlin-android-extensions&#39;...dependencies &#123; ... implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot; ...&#125; 因此，在已有的Java Android项目中做出上述改动后，该项目也就可以用上Kotlin做开发啦，Kotlin和Java也可以很好的协同工作，当然，如果要这么做，请仔细斟酌并进行足够的测试。 2.2 添加一个Activity在项目目录中，选中app/src/main/包名文件夹单击鼠标右键，在弹出菜单中选中New菜单，接着在弹出菜单中选中Activity菜单，最后在弹出菜单中选中Empty Activity单击鼠标左键，如图所示： 选择Empty Activity AS将弹出一个Activity的配置对话框，将各个属性配置好，注意由于项目中没有启动的第一个Activity，所以要勾选Launcher Activity，同时注意Source Language的选项要是Kotlin，如图所示： 配置Activity 点击Finish后，AS会建立相应的layout和kt文件，kt文件就相当于java文件。现在这个新的Activity还是一个空白的页面，我们可以给它加一个TextView，给它设置内容，看看Kotlin与Java的不同之处。 layout与之前还是一样的，代码如下： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/text_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\"/&gt;&lt;/FrameLayout&gt; Kotlin的不同还是比较多的，代码如下: 123456789101112import android.support.v7.app.AppCompatActivityimport android.os.Bundleimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) text_view.text &#x3D; &quot;Hello World !&quot; &#125;&#125; 这样一个Hello World的TextView就可以显示在界面中了，run一遍看看效果和Java的没什么区别。简单看一下kt文件我们可以看到一些和Java的区别： 导入了一个kotlinx.android.synthetic.main.activity_main.*，这个import可以让layout中的控件可以直接用id来调用，省略了findViewById()这一个步骤。 Kotlin去掉了语句末尾的;，让少写了’;’而导致编译失败的问题从此消失。 继承关系直接用:表示，接口的实现也是用的:表示，似乎在精简代码的同时让人有点迷糊。 override变成了一个修饰语，不再是注解的形式。 变量的表示使用了变量名: 类名的形式，?代表了此变量可以为空，空安全也是Kotlin的主打特点。 对象的属性看上去可以直接操作，实际是来自get()/set()，似乎在精简代码的同时让人感觉增加了耦合性。 当然区别不止这几点，只是在一个最简单的APP中都存在的上述几点区别，可以看出一些Kotlin的设计理念，应该旨在解决一些Java过于冗杂和不太安全的问题。","categories":[{"name":"Kotlin征途","slug":"Kotlin征途","permalink":"https://coder-ice.gitee.io/categories/Kotlin%E5%BE%81%E9%80%94/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://coder-ice.gitee.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://coder-ice.gitee.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://coder-ice.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"MarkDown使用教程(In Atom)","slug":"MarkDown使用教程(In Atom)","date":"2019-06-15T08:11:45.000Z","updated":"2020-02-21T03:00:45.723Z","comments":true,"path":"2019/06/15/MarkDown使用教程(In Atom)/","link":"","permalink":"https://coder-ice.gitee.io/2019/06/15/MarkDown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B(In%20Atom)/","excerpt":"程序猿都爱写博客，在写博客的过程中，大量运用的就是MarkDown语法了。MarkDown不只是用来写博客，日常生活中的感悟、工作中的心得体会、项目任务安排等等大篇幅的文章都可以用MarkDown来迅速的完成具有一定显示效果的文本。","text":"程序猿都爱写博客，在写博客的过程中，大量运用的就是MarkDown语法了。MarkDown不只是用来写博客，日常生活中的感悟、工作中的心得体会、项目任务安排等等大篇幅的文章都可以用MarkDown来迅速的完成具有一定显示效果的文本。 1. MarkDown的编写工具 工欲善其事，必先利其器，要学习MarkDown，编写工具是必不可少的。 其实严格来说，MarkDown没有专门的编写工具，通过简单的文本编辑器即可编写MarkDown文本，比如Windows的记事本。但简单的文本编辑器功能欠缺，没有高亮的文字表现，更没有文本效果可言，就像没有人用记事本写代码一样，最起码也得用个Edit Plus。 笔者菜鸟一枚，最近开始接触MarkDown，挑选的编辑器是Atom，GitHub出品的简洁强大的编辑器，插件众多，支持的语言也比较多，也是一个不错的前端开发编辑器。 1.1 simplified-chinese-menu中文插件使用Atom时，首先对满屏的英文就有点抗拒，虽然写程序都用的英文，但对一些菜单、提示语还是更喜欢中文。 simplified-chinese-menu这个插件基本将Atom里的各个菜单及提示语做到了汉化，瑕疵比较少，Atom装上这个插件，新手用起来方便多了。 1.2 markdown-scroll-sync同步滚动插件markdown-scroll-sync同步滚动插件可以让预览与文本保持同步，减少查看预览的时间，确实是更方便了一些。 1.3 markdown-table-editor表格编辑插件MarkDown在编写表格时稍微有些吃力，空格、对齐什么的，手敲太慢了有木有！！！markdown-table-editor表格编辑插件，让表格的编写更简单，你值得拥有。 2. MarkDown的基础语法如果不算扩展，Markdown的语法绝对简单到让你爱不释手！Markdown语法分为如下几大部分： 标题 段落 引用 代码块 强调 列表 分割线 链接 图片 表格 流程图 2.1 标题利用#标识标题，最对可以标识六级标题，#是一级标题，字体最大，######是六级标题，字体最小，示例如下： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 示例图片 2.2 段落段落，在word中以回车换行来标识，而在md中需要一行空行进行分割两个段落，同一个段落中的多个空格、tab、回车符将被删减为一个空格（部分展示md的浏览器中，回车符可以表现为段内换行），在段落中允许存在换行，使用方式为两个以上空格加回车符，示例如下： 1234567这是段落一，下面是一行空行。这是段落二，这是一个空格 ，这是五个空格 ，这是两个tab ，这是一个回车符，下面将用两个空格加回车进行段落内换行 换行完成，还是段落二。这是段落三。 效果如下： 这是段落一，下面是一行空行。 这是段落二，这是一个空格 ，这是五个空格 ，这是两个tab ，这是一个回车符，下面将用两个空格加回车进行段落内换行换行完成，还是段落二。 这是段落三。 2.3 引用md中使用&gt;来标识一个段落的引用，引用可以使用多个&gt;进行嵌套，示例如下： 123&gt;这里是引用的段落&gt;&gt;这里是一层嵌套的引用&gt;&gt;&gt;这里是两层嵌套的引用 效果如下： 这里是引用的段落 这里是一层嵌套的引用 这里是两层嵌套的引用 2.4 代码块作为程序猿，代码在博客中必不可少，md中对代码块是有三种标识方式的。第一中是行内代码标识，用一对反引号来包裹几个字符，效果有些类似软件中常见的标签。第二种是在行前添加四个空格来标识一行代码，但此行前一行只能为空行或者代码块。第三种是使用一对三个反引号包裹一大段文字，可以标识一段代码，在三个反引号后可以加语言名称来达到关键字高亮效果。（PS：反引号在键盘左上角Esc按钮下方，第一次用时笔者还以为是单引号）示例如下： 12345678910111213141516171819这里有一个行内代码&#96;code&#96;，下面有两行代码： a line codes a line codes下面有一段代码：（&#96;&#96;&#96;）code and code and codecode and code and code（&#96;&#96;&#96;）下面有一段Java代码：（&#96;&#96;&#96;java）public class Hello&#123; public static void main (String[] args) &#123; System.out.println(&quot;Hello world !&quot;); &#125;&#125;（&#96;&#96;&#96;） 注：为了防止代码块标识符被转译，笔者在三个反引号前后加了括号，使用时应去除括号。 效果如下： 这里有一个行内代码code，下面有两行代码： a line codes a line codes下面有一段代码： 12code and code and codecode and code and code 下面有一段Java代码： 12345public class Hello&#123; public static void main (String[] args) &#123; System.out.println(\"Hello world !\"); &#125;&#125; 2.5 强调强调效果有粗体和斜体两种，一对*符号包裹的字符会显示为斜体，而一对**包裹的字符会显示为粗体，示例如下： 1这是*斜体*，这是**粗体** 效果如下： 这是斜体，这是粗体 2.6 列表列表的编写相当方便，无序列表只需在行前加+/-/*符号加空格即可，有序列表则在行前加1.等序号加空格即可，列表内容加入[ ]或[x]可用来标识待办事项，示例如下： 123456789101112+ 无序列表- 无序列表* 无序列表1. 有序列表2. 有序列表3. 有序列表* [ ] 待办1* [x] 待办21. [ ] 待办32. [x] 待办4 效果如下： 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 待办1 待办2 待办3 待办4 2.7 分割线分割线在各个浏览器的显示形式都有所不同，使用三个*/-/_均可以实现一根分割线，示例如下： 123***---___ 效果如下： 2.8 链接在md中想要跳转到某个外链，可以使用两种方式完成，第一种是md语法[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加，这种方式可能无法在当前标签页中打开网址，第二种是使用html中的&lt;a&gt;标签，可以指定target来控制网址打开方式。示例如下： 123[百度](http:&#x2F;&#x2F;www.baidu.com&#x2F; &quot;百度一下&quot;)&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;百度&lt;&#x2F;a&gt; 效果如下： 百度 百度 2.9 图片图片的使用方式有些类似链接，在链接的格式前方加!即可，即![图片名](图片地址)，示例如下： 1![github头像](https:&#x2F;&#x2F;github.com&#x2F;fluidicon.png) 效果如下： github头像 2.10 表格常常在文章中需要使用表格来罗列事项、比对事物，md支持了表格的简单形式，使用方式即使用|和-符号进行组合，示例如下： 1234| 表头一 | 表头二 || --------- | --------- || 表格内容一 | 表格内容二 || 表格内容三 | 表格内容四 | 注：对齐居中等不需要太注意 效果如下： 表头一 表头二 表格内容一 表格内容二 表格内容三 表格内容四 2.11 流程图markdown本身并不能直接转换流程图，但可以通过插件来完成，感兴趣的童鞋可以了解一下。不过笔者看来在markdown里写流程图还是比较麻烦的，简单的还好，复杂一点的就有点烧脑了。","categories":[{"name":"工作之余","slug":"工作之余","permalink":"https://coder-ice.gitee.io/categories/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://coder-ice.gitee.io/tags/MarkDown/"},{"name":"博客","slug":"博客","permalink":"https://coder-ice.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"利用GitHub和Hexo打造免费的个人博客","slug":"利用GitHub和Hexo打造免费的个人博客","date":"2019-06-01T03:30:30.000Z","updated":"2019-06-12T08:12:52.061Z","comments":true,"path":"2019/06/01/利用GitHub和Hexo打造免费的个人博客/","link":"","permalink":"https://coder-ice.gitee.io/2019/06/01/%E5%88%A9%E7%94%A8GitHub%E5%92%8CHexo%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"每个程序猿都需要一个个人博客，目前广泛出现在大家视野里的有CSDN、博客园、简书，但是他们却没有给用户一个专属的站点、一个好记的域名。你需要一个http://xxx.xxx.xxx/格式的网址，一个自由书写代码的站点，一个真正的个人博客。","text":"每个程序猿都需要一个个人博客，目前广泛出现在大家视野里的有CSDN、博客园、简书，但是他们却没有给用户一个专属的站点、一个好记的域名。你需要一个http://xxx.xxx.xxx/格式的网址，一个自由书写代码的站点，一个真正的个人博客。 1. GitHub提供的免费网站1.1 GitHub——面向开源及私有软件项目的托管平台GitHub官网 作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。——来源：百度百科 GitHub是目前最大的代码仓库，如果你还没有GitHub账号的话，就赶紧去官网注册一个吧。 1.2 GitHub Pages——免费提供最基础的静态网站GitHub Pages官网 每个GitHub账户都可以免费开一个自己的静态网站（域名为 username.github.io），该网站由GitHub Pages提供，省去了域名、服务器、备案等一系列建站需要考虑的问题，只需要一份静态网站的代码即可。 首先你需要创建一个GitHub Pages repository。GitHub Pages repository跟普通的repository是一样的，唯一的区别就是他的名字必须叫做username.gihub.io。这个官方教程 GitHub Pages 写的十分好懂，按这个做完之后你就有了一个你的网址username.github.io！ 比如你的GitHub用户名是abc，那么你的repository名称和网址就是abc.gihub.io 现在离一个好网站只差一步了，就是把某个好网站的所有文件拷贝到你的库里面。GitHub官方建议你使用博客生成工具Jekyll 。GitHub在库的设置里面还提供Jekyll主题选择。 本文将介绍的是Hexo生成工具。 2. Hexo搭建的静态博客网站2.1 Hexo——快速、简洁且高效的博客框架Hexo官网 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 2.1.1 安装前提安装Hexo相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js (Should be at least nodejs 6.9) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 2.1.2 安装 GitWindows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。Linux (Ubuntu, Debian)：sudo apt-get install git-core。 Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core。 Windows 用户由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 2.1.3 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https:&#x2F;&#x2F;raw.github.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.11&#x2F;install.sh | sh Wget: 1$ wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.11&#x2F;install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 2.1.4 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 2.1.5 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 2.2 Hexo的自定义配置及博客主题2.2.1 _config.yml网站的配置信息，您可以在此配置大部分的参数。文件内各个配置参数均有详细备注，按规则填入所需即可。 2.2.2 package.json应用程序的信息，EJS、 Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; 2.2.3 scaffolds模版文件夹，当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 2.2.4 source资源文件夹是存放用户资源的地方，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 2.2.5 themes主题文件夹，Hexo 会根据主题来生成静态页面。GitHub上存在许多第三方主题，根据主题的文档介绍引入Hexo项目中，会在主题文件夹下生成一个相应的文件夹，再修改_config.xml文件夹的theme属性即可。 本文将要介绍的是Indigo主题。 3. Indigo主题——Material Design 风格的Hexo主题Indigo in GitHub 仅支持 IE10+ 等现代浏览器。去 jQuery，更轻。相信现代浏览器的原生兼容性。使用 Less 作为 css 预处理器，需要安装 hexo-renderer-less。添加了英文字体支持 Roboto。添加了一些波纹效果。无前端依赖的分享实现。基于静态数据的站内搜索，无第三方侵入。支持文章打赏。 现有两个主题分支，我的博客中使用的是card分支卡片风格主题，master分支是旧版平铺式风格主题。 3.1 安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。 1git clone git@github.com:yscoder&#x2F;hexo-theme-indigo.git themes&#x2F;indigo 3.1.1 切换主题执行git branch显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。 12345# 获取远程 card 分支，并切换$ git checkout -b card origin&#x2F;card# 获取远程 master 分支，并切换$ git checkout -b master origin&#x2F;master 此命令只需执行一次，之后使用git checkout [branch]命令在两个主题之间切换。 3.1.2 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less 主题默认使用 less 作为 css 预处理工具。 1$ npm install hexo-renderer-less --save Feed 用于生成 rss。 1$ npm install hexo-generator-feed --save Json-content 用于生成静态站点数据，用作站内搜索的数据源。 1$ npm install hexo-generator-json-content --save QRCode 用于生成微信分享二维码。 可选，不安装时会请求jiathis Api生成二维码。 1$ npm install hexo-helper-qrcode --save 3.1.3 开启标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 3.1.4 开启分类页仅 card theme 支持。 1hexo new page categories 修改 hexo/source/categories/index.md 的元数据 123layout: categoriescomments: false--- 3.2 常见问题3.2.1 如何设置文章摘要在 Markdown 中加&lt;!-- more --&gt; 3.2.2 文章如何添加多个标签有两种多标签格式 1tags: [a, b, c] 或 1234tags: - a - b - c 3.2.3 修改 brand 图片（菜单上方背景图）替换 themes\\indigo\\source\\img\\brand.jpg，保持原文件名不变。 3.2.4 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class&#x3D;&quot;icon icon-book&quot;&gt;&lt;&#x2F;i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-lg&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-2x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-3x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-4x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-5x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-pr&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-pl&quot;&gt;&lt;&#x2F;i&gt; 3.2.5 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 3.2.6 生成站点后没有样式安装less 3.2.7 自行修改样式线上不生效因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的cdn: false。这样就不在引用cdn资源，使用本地资源了。 3.2.8 更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 建议每次提交时都执行一次hexo clean，可以在项目目录下创建一个shell脚本，执行命令hexo clean &amp;&amp; hexo generate --deploy，运行后即可保证每次修改都能生效。 3.2.9 更改站点配色编辑 themes\\indigo\\source\\css_partial\\variable.less，更改对应的颜色变量。 配色参考：Material Design Color Palette Generator 注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。 3.2.10 添加404页面在 hexo/source 目录内新建 404.html。 设置元数据信息，如果不想套用主题布局可设置 layout 为 false。 123layout: false title: &quot;My Blog Name | 404&quot;--- 3.2.11 在博客中使用 Emoji参考 Can i use emoji in mypage? 3.3 自定义页面主题 Card 分支为自定义页面提供了定制化模块支持，特此简单介绍。 3.3.1 创建自定义页面1hexo new page pageName 执行命令后会在你的 Hexo 根目录 source/ 目录下生成一个与你刚才输入的 pageName 一样的文件夹，里面只有一个 index.md。 3.3.2 页面配置123456layout: page # 必须title: pageTitle # 必须，页面名称description: 用户自定义页面功能演示 # 页面二级标题，描述性文字comments: false # 禁用评论，可选，默认开启reward: false # 禁用打赏，可选，默认开启---- 3.3.3 模块和内容输入自定义页面中，image、blockquote、pre 等将被赋予特殊的样式。此外，提供了@moduleName{ ... }格式的标记用于包裹内容，赋予样式。","categories":[{"name":"工作之余","slug":"工作之余","permalink":"https://coder-ice.gitee.io/categories/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E4%BD%99/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://coder-ice.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://coder-ice.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://coder-ice.gitee.io/tags/hexo/"}]}]}